<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Unidad 1 - Programación Numérica</title>

  <style>
    body {
      font-family: "Poppins", sans-serif;
      background-color: #0b0c10;
      color: #f5f6fa;
      margin: 0;
      overflow-x: hidden;
    }

    main {
      max-width: 900px;
      margin: 80px auto;
      background: rgba(255, 255, 255, 0.05);
      padding: 40px;
      border-radius: 20px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
    }

    h2 {
      text-align: center;
      color: #00aaff;
      text-shadow: 0 0 5px #00aaff;
    }

    .card {
      background: rgba(255, 255, 255, 0.05);
      padding: 15px 25px;
      margin-bottom: 15px;
      border-radius: 12px;
      transition: transform 0.3s ease, background 0.3s ease;
      cursor: pointer;
    }

    .card:hover {
      transform: scale(1.03);
      background: rgba(0, 170, 255, 0.15);
    }

    .card h4 {
      color: #00ffcc;
      margin: 0;
    }

    .actividad-detalle {
      display: none;
      margin-top: 20px;
      background: rgba(255, 255, 255, 0.07);
      padding: 25px;
      border-radius: 10px;
      animation: fadeIn 0.4s ease-in-out;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(-10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    pre {
      background: rgba(0, 0, 0, 0.7);
      padding: 15px;
      border-radius: 10px;
      overflow-x: auto;
      font-size: 0.9em;
      color: #00ffcc;
    }

    iframe {
      display: block;
      width: 100%;
      height: 400px;
      border: none;
      margin-top: 15px;
      border-radius: 10px;
    }

    a.btn {
      display: inline-block;
      margin-top: 10px;
      background: #00aaff;
      color: white;
      padding: 10px 20px;
      border-radius: 8px;
      text-decoration: none;
      transition: background 0.3s;
    }

    a.btn:hover {
      background: #0088cc;
    }

    canvas#network {
      position: fixed;
      top: 0;
      left: 0;
      z-index: -1;
    }

    footer {
      text-align: center;
      margin-top: 40px;
      color: #00aaff;
    }
  </style>
</head>
<body>
  <canvas id="network"></canvas>

  <main>
    <h2>Contenido de la Unidad 1</h2>
    <p>En esta unidad desarrollaré tareas sobre los fundamentos y aplicaciones de la programación numérica.</p>

    <h3>Actividades</h3>

    <!-- TAREA 1 -->
    <div class="card" onclick="mostrar('tarea1')">
      <h4>Tarea 1: Análisis de funciones</h4>
    </div>
    <div class="actividad-detalle" id="tarea1">
      <p><strong>Problema:</strong> Se desea desarrollar un programa que, dado una función matemática ingresada por el usuario con un máximo de dos variables, identifique cuáles son esas variables y cuente el número de operaciones presentes, incluyendo sumas, restas, multiplicaciones, divisiones, potencias y multiplicaciones implícitas (como 5x o xy).</p>
      <h4>Código utilizado:</h4>
      <pre>
import tkinter as tk
from tkinter import ttk, messagebox
import sympy as sp
import re

def analizar():
    expresion = entrada.get().strip()

    if not expresion:
        messagebox.showwarning("Error", "Por favor ingresa una expresión matemática.")
        return

    # Reemplazar ^ por ** para potencias
    expresion = expresion.replace("^", "**")

    # 🔹 Agregar * cuando falta (ej: 5x -> 5*x, 2y -> 2*y, xy -> x*y)
    expresion = re.sub(r'(\d)([a-zA-Z])', r'\1*\2', expresion)
    expresion = re.sub(r'([a-zA-Z])(\d)', r'\1*\2', expresion)
    expresion = re.sub(r'([a-zA-Z])([a-zA-Z])', r'\1*\2', expresion)

    try:
        if "=" in expresion:
            izquierda, derecha = expresion.split("=")
            lhs = sp.sympify(izquierda.strip())
            rhs = sp.sympify(derecha.strip())
            eq = sp.Eq(lhs, rhs)
        else:
            lhs, rhs = sp.symbols("y"), sp.sympify(expresion)
            eq = sp.Eq(lhs, rhs)

        variables = list(eq.free_symbols)
        num_vars = len(variables)

        y = sp.Symbol("y")
        if y in variables:
            soluciones = sp.solve(eq, y)
        else:
            var_dep = variables[0]
            soluciones = sp.solve(eq, var_dep)

        operaciones = sum(expresion.count(op) for op in "+-*/**")

        resultado_texto = f"Expresión: {expresion}\n"
        resultado_texto += f"Variables encontradas: {', '.join(str(v) for v in variables)}\n"
        resultado_texto += f"Número de variables: {num_vars}\n"
        resultado_texto += f"Número de operaciones: {operaciones}\n"

        if len(soluciones) == 1:
            resultado_texto += f" Es función: {soluciones[0]}"
        elif len(soluciones) > 1:
            resultado_texto += f"NO es función (múltiples salidas: {soluciones})"
        else:
            resultado_texto += " No se pudo determinar si es función."

        resultado.set(resultado_texto)

    except Exception as e:
        messagebox.showerror("Error", f"No se pudo analizar la expresión.\n{e}")

# ---------------------------
ventana = tk.Tk()
ventana.title("Analizador Avanzado de Funciones")
ventana.geometry("500x400")
ventana.configure(bg="#f4f6f7")

estilo = ttk.Style()
estilo.configure("TButton", font=("Arial", 12), padding=6)
estilo.configure("TLabel", font=("Arial", 12))

titulo = tk.Label(
    ventana, text="🔎 Analizador Avanzado de Funciones", 
    font=("Arial", 16, "bold"), bg="#f4f6f7", fg="#2c3e50"
)
titulo.pack(pady=10)

entrada = ttk.Entry(ventana, font=("Consolas", 14))
entrada.pack(pady=10, ipadx=20, ipady=5)

btn = ttk.Button(ventana, text="Analizar", command=analizar)
btn.pack(pady=10)

resultado = tk.StringVar()
label_resultado = tk.Label(
    ventana, textvariable=resultado, 
    font=("Consolas", 12), bg="#ecf0f1", fg="#2c3e50", 
    relief="groove", justify="left", anchor="w"
)
label_resultado.pack(fill="both", expand=True, padx=20, pady=10)

ventana.mainloop()
      </pre>
      <a href="Actividad_1_.pdf" target="_blank" class="btn">Ver PDF</a>
    </div>

    <!-- TAREA 2 -->
    <div class="card" onclick="mostrar('tarea2')">
      <h4>Tarea 2: Gráficas de funciones lineales </h4>
    </div>
    <div class="actividad-detalle" id="tarea2">
      <p><strong>Problema:</strong> Se desea desarrollar un programa que, dado una función matemática ingresada por el usuario con un máximo de dos variables, identifique cuáles son esas variables y cuente el número de operaciones presentes, incluyendo sumas, restas, multiplicaciones, divisiones, potencias y multiplicaciones implícitas (como 5x o xy)..</p>
      <h4>Código utilizado:</h4>
      <pre>
def preparar_expresion(expr: str) -> str:
          expr = expr.replace(" ", "")          # quitar espacios
          expr = expr.replace("^", "**")        # potencia
          expr = expr.replace("-x", "-1*x")     # caso -x
          expr = expr.replace("+x", "+1*x")     # caso +x
          if expr.startswith("x"):              # si empieza con x
              expr = "1*" + expr
          expr = expr.replace("x", "*x")        # poner multiplicación
          expr = expr.replace("**x", "*x")      # corregir si se duplicó
          return expr

      # Pedimos las dos funciones
      func1 = input("Ingrese la primera función (ejemplo: 2x+1): ")
      func2 = input("Ingrese la segunda función (ejemplo: -x+3): ")

      func1 = preparar_expresion(func1)
      func2 = preparar_expresion(func2)

      # Definimos el rango del gráfico (valores de X y Y)
      xmin, xmax = -20, 20
      ymin, ymax = -20, 20

      # Recorremos los valores de Y de arriba hacia abajo
      for y in range(ymax, ymin - 1, -1):
          linea = ""

          for x in range(xmin, xmax + 1):
              try:
                  y1 = eval(func1)
              except:
                  y1 = None
              try:
                  y2 = eval(func2)
              except:
                  y2 = None

              cond1 = (y1 is not None and abs(y - y1) < 0.5)
              cond2 = (y2 is not None and abs(y - y2) < 0.5)

              if cond1 and cond2:
                  linea += "#"
              elif cond1:
                  linea += "*"
              elif cond2:
                  linea += "o"
              elif x == 0 and y == 0:
                  linea += "+"
              elif x == 0:
                  linea += "|"
              elif y == 0:
                  linea += "-"
              else:
                  linea += " "
          print(linea)

      # Leyenda
      print("\nLeyenda del gráfico:")
      print("  * = Función 1")
      print("  o = Función 2")
      print("  # = Intersección")
      print("  | = Eje Y")
      print("  - = Eje X")
      print("  + = Origen (0,0)")
      </pre>
      <a href="Actividad_2_.pdf" target="_blank" class="btn">Ver PDF</a>
    </div>

    <!-- TAREA 3 -->
    <div class="card" onclick="mostrar('tarea3')">
      <h4>Tarea 3: Método de Bisección</h4>
    </div>
    <div class="actividad-detalle" id="tarea3">
      <p><strong>Problema:</strong> Las restricciones son condiciones que limitan el conjunto de valores posibles que pueden tomar las variables en un problema. Estas son esenciales en problemas de optimización y en sistemas de ecuaciones, ya que definen la región factible, es decir, el espacio de soluciones posibles. En ese sentido se proponen 5 ejercicios que deben ser desarrollados utilizando las restricciones y el código del anterior trabajo para realizar una representación gráfica.</p>
      <h4>Enunciado:</h4>
      <pre>
      Un desarrollador tiene 15 horas semanales para dedicar al desarrollo de software de front-end (x) y back-end (y). Además:
• Debe dedicar al menos 5 horas al desarrollo de front-end para cumplir con los entregables del cliente.
• El tiempo total no puede exceder 15 horas por restricciones de tiempo del sprint.
Formule las restricciones, represéntelas gráficamente e identifique las combinaciones posibles de tiempo a invertir en cada actividad.

Un ingeniero de datos administra dos tipos de servidores en la nube: Servidores A y Servidores B. El costo por hora de Servidor A es S/3 y de Servidor B es S/5. El presupuesto máximo semanal asignado para mantener los servidores es de S/20.
Determine cuántas horas puede mantener activos cada tipo de servidor, formule el sistema de ecuaciones y represéntelo gráficamente.

Un administrador de proyectos tecnológicos organiza su tiempo entre reuniones con stakeholders (x) y trabajo en la documentación técnica (y). Las reuniones requieren al menos 4 horas semanales y la documentación al menos 6 horas. Si dispone de 12 horas para ambas actividades,
determine la región factible y analice las combinaciones posibles de tiempo.

Una empresa de desarrollo de videojuegos produce dos tipos de assets: Modelos 3D (P₁) y Texturas (P₂). Cada modelo 3D requiere 2 horas de trabajo y cada textura requiere 3 horas. El equipo de arte tiene un total de 18 horas disponibles semanalmente.
Formule las restricciones, represéntelas gráficamente y determine cuántos assets de cada tipo pueden producirse en función del tiempo disponible.

Una startup de hardware dispone de un máximo de 50 unidades de componentes electrónicos. Para ensamblar un dispositivo tipo A se necesitan 5 unidades y para un dispositivo tipo B se necesitan 10 unidades.
Determine cuántos dispositivos de cada tipo puede ensamblar sin exceder las 50 unidades de componentes. Formule el problema, resuélvalo gráficamente y explique las posibles combinaciones de producción.
      </pre>
      <a href="Actividad_3.pdf" target="_blank" class="btn">Ver PDF</a>
    </div>

    <!-- TAREA 4 -->
    <div class="card" onclick="mostrar('tarea4')">
      <h4>Tarea 4: Método de  Regula Falsi</h4>
    </div>
    <div class="actividad-detalle" id="tarea4">
      <p><strong>Problema:</strong>El método de la Regula Falsi, también conocido como falsa posición, es una técnica numérica utilizada para encontrar raíces reales de una ecuación no lineal. Se basa en el principio de interpolación lineal entre dos puntos del intervalo donde la función cambia de signo, garantizando así la existencia de al menos una raíz dentro de ese rango.</p>
     
      <a href="ACTIVIDAD 4.pdf" target="_blank" class="btn">Ver PDF</a>
    </div>
  </main>

                <!-- TAREA 5 -->
    <div class="card" onclick="mostrar('tarea4')">
      <h4>Tarea 4: Método de Newton-Rapson</h4>
    </div>
    <div class="actividad-detalle" id="tarea4">
      <p><strong>Problema:</strong>El método de la Newton Rapson, también conocido como falsa posición, es una técnica numérica utilizada para encontrar raíces reales de una ecuación no lineal. Se basa en el principio de interpolación lineal entre dos puntos del intervalo donde la función cambia de signo, garantizando así la existencia de al menos una raíz dentro de ese rango.</p>
     
      <a href="Actividad_05.pdf" target="_blank" class="btn">Ver PDF</a>
    </div>
  </main>
  <footer>© 2025 -LUIS ANGEL QUENAYA LOZA</footer>

  <script>
    // Mostrar / ocultar actividades
    function mostrar(id) {
      const detalles = document.querySelectorAll('.actividad-detalle');
      detalles.forEach(d => {
        if (d.id === id) {
          d.style.display = (d.style.display === "block") ? "none" : "block";
        } else {
          d.style.display = "none";
        }
      });
    }

    // Fondo de red neuronal animado
    const canvas = document.getElementById('network');
    const ctx = canvas.getContext('2d');
    let w, h, nodes;

    function resizeCanvas() {
      w = canvas.width = window.innerWidth;
      h = canvas.height = window.innerHeight;
      nodes = Array(70).fill().map(() => ({
        x: Math.random() * w,
        y: Math.random() * h,
        vx: (Math.random() - 0.5) * 0.8,
        vy: (Math.random() - 0.5) * 0.8
      }));
    }

    function animate() {
      ctx.clearRect(0, 0, w, h);
      nodes.forEach(a => {
        a.x += a.vx;
        a.y += a.vy;
        if (a.x < 0 || a.x > w) a.vx *= -1;
        if (a.y < 0 || a.y > h) a.vy *= -1;
        ctx.beginPath();
        ctx.arc(a.x, a.y, 2, 0, Math.PI * 2);
        ctx.fillStyle = "#00aaff";
        ctx.fill();
        nodes.forEach(b => {
          const dx = a.x - b.x, dy = a.y - b.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < 120) {
            ctx.beginPath();
            ctx.moveTo(a.x, a.y);
            ctx.lineTo(b.x, b.y);
            ctx.strokeStyle = "rgba(0, 170, 255, 0.12)";
            ctx.stroke();
          }
        });
      });
      requestAnimationFrame(animate);
    }

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();
    animate();
  </script>
</body>
</html>

