<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Unidad 2 ‚Äî Lista de actividades</title>

    <script>
        // Configuraci√≥n expl√≠cita de MathJax (para asegurar el uso de $$...$$)
        MathJax = {
            tex: {
                // Habilita tanto las dobles barras (\\( y \\)) como los dobles d√≥lares ($$)
                inlineMath: [['$', '$'], ['\\(', '\\)']], 
                displayMath: [['$$', '$$'], ['\\[', '\\]']] 
            },
            svg: {
                fontCache: 'global'
            }
        };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
    </script>
    <style>
        :root{
            --azul-1:#00aaff;
            --azul-2:#004b9a;
            --blanco:#ffffff;
            --negro:#0b0c10;
            --panel: rgba(255,255,255,0.04);
        }
        html,body{
            height:100%;
            margin:0;
            font-family:"Poppins", Arial, sans-serif;
            background:var(--negro);
            color:var(--blanco);
            -webkit-font-smoothing:antialiased;
            overflow:hidden; /* Se cambia a 'auto' al abrir la vista de detalle */
        }
        .bg-canvas{position:fixed;inset:0;z-index:0;pointer-events:none}
        .app{position:relative;z-index:2;min-height:100vh;display:flex;flex-direction:column;align-items:center}
        header{width:100%;text-align:center;padding:48px 20px 10px;box-sizing:border-box;z-index:3}
        header h1{margin:0;font-size:3rem;color:var(--azul-1);text-shadow:0 0 18px rgba(0,170,255,0.12)}
        header h2{margin:6px 0 0;font-weight:400;color:rgba(255,255,255,0.85)}
        .grid-wrap{width:100%;max-width:1100px;padding:28px 20px;box-sizing:border-box;z-index:3;flex:1;display:flex;align-items:flex-start;justify-content:center}
        .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));gap:16px;width:100%}.card{
            background:var(--panel);
            padding:18px;
            border-radius:12px;
            cursor:pointer;
            transition:transform .28s ease, background .28s ease, box-shadow .28s;
            box-shadow: 0 6px 18px rgba(0,0,0,0.45);
            backdrop-filter: blur(4px);
        }
        .card h3{margin:0;color:var(--azul-1);font-size:1.05rem}
        .card p{margin:8px 0 0 0;color:rgba(255,255,255,0.88);font-size:.92rem}
        .card:hover{
            transform: translateY(-8px) scale(1.02);
            background: linear-gradient(180deg, rgba(0,170,255,0.08), rgba(255,255,255,0.02));
            box-shadow: 0 14px 40px rgba(0,170,255,0.12);
        }
        .detail-screen{display:none;position:fixed;inset:0;background:linear-gradient(180deg, rgba(1,6,20,0.95), rgba(0,0,0,0.96));z-index:30;overflow:auto;padding:36px;box-sizing:border-box;opacity:0;transform: translateX(30px);transition: opacity .32s ease, transform .32s ease;}
        .detail-screen.show{ display:block; opacity:1; transform: translateX(0); }
        .detail-inner{max-width:1100px;margin:0 auto;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:18px;box-shadow:0 20px 60px rgba(0,0,0,0.7)}
        .detail-head{display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap}
        .detail-head h2{margin:0;color:var(--azul-1)}
        .controls{display:flex;gap:10px;align-items:center}
        .btn{background:var(--azul-1);color:var(--negro);padding:10px 14px;border-radius:10px;border:none;cursor:pointer;font-weight:700;box-shadow:0 10px 30px rgba(0,170,255,0.12)}
        .btn.secondary{background:#ffffff;color:var(--azul-2)}
        .btn.ghost{background:transparent;color:var(--blanco);border:1px solid rgba(255,255,255,0.06)}
        .content-columns{display:grid;grid-template-columns:1fr 340px;gap:18px;margin-top:14px}
        .enunciado{background:rgba(255,255,255,0.02);padding:14px;border-radius:8px;min-height:160px;color:#e7f7ff;line-height:1.5;}
        .enunciado a {color: var(--azul-1); text-decoration: none;}
        .enunciado a:hover {text-decoration: underline;}
        pre.code{background:#030409;color:#e6fbff;border-left:6px solid var(--azul-2);padding:12px;border-radius:8px;overflow:auto;font-family:Consolas,monospace;white-space: pre-wrap;}
        .meta-card{background:var(--panel);padding:12px;border-radius:8px;margin-bottom:12px}
        .footer-small{text-align:center;color:rgba(255,255,255,0.6);margin-top:26px}
        .volver-floating{position:fixed;right:20px;bottom:18px;z-index:40}
        .volver-floating .btn{padding:10px 12px;border-radius:12px}

        /* ======================
            ESTILO PARA F√ìRMULAS
            ====================== */
        .formula {
            background: rgba(0, 75, 154, 0.2); 
            color: var(--blanco);
            padding: 12px;
            border-left: 5px solid var(--azul-1); 
            margin: 15px 0;
            border-radius: 6px;
            box-shadow: 0 0 10px rgba(0, 170, 255, 0.1);
            overflow-x: auto;
        }

        /* Estilos para tablas en description (Actividad 6) */
        .activity-table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            background: rgba(255,255,255,0.05);
            border-radius: 6px;
        }

        .activity-table th, .activity-table td {
            border: 1px solid rgba(255,255,255,0.1);
            padding: 10px;
            text-align: left;
            font-size: 0.9em;
        }

        .activity-table th {
            background-color: rgba(255,255,255,0.08);
            color: var(--azul-1);
        }
        
        @media (max-width:980px){.content-columns{grid-template-columns:1fr}header h1{font-size:2.2rem}}
    </style>

</head>
<body>

    <canvas id="gradCanvas" class="bg-canvas"></canvas>
    <canvas id="barsCanvas" class="bg-canvas"></canvas>
    <canvas id="netCanvas" class="bg-canvas"></canvas>

    <script>
        // CANVAS 1
        (function(){
            const c = document.getElementById("gradCanvas");
            const ctx = c.getContext("2d");
            function resize(){ c.width = innerWidth; c.height = innerHeight; }
            resize(); addEventListener("resize", resize);
            let t = 0;
            function draw(){
                t += 0.005;
                const g = ctx.createLinearGradient(0, 0, c.width * Math.cos(t), c.height * Math.sin(t));
                g.addColorStop(0, "#00101f");
                g.addColorStop(0.5, "#002b45");
                g.addColorStop(1, "#001a2c");
                ctx.fillStyle = g;
                ctx.fillRect(0,0,c.width,c.height);
                requestAnimationFrame(draw);
            }
            draw();
        })();

        // CANVAS 2
        (function(){
            const c = document.getElementById("barsCanvas");
            const ctx = c.getContext("2d");
            function resize(){ c.width = innerWidth; c.height = innerHeight; }
            resize(); addEventListener("resize", resize);
            const bars = []; const count = 35;
            for(let i=0;i<count;i++){
                bars.push({ x: Math.random()*c.width, h: 80+Math.random()*300, speed:0.4+Math.random()*0.6, alpha:0.08+Math.random()*0.12 });
            }
            function draw(){
                ctx.clearRect(0,0,c.width,c.height);
                bars.forEach(b=>{
                    ctx.fillStyle = `rgba(0,170,255,${b.alpha})`;
                    ctx.fillRect(b.x, 0, 2, b.h);
                    b.h += Math.sin(Date.now()*0.001 + b.x)*0.6;
                });
                requestAnimationFrame(draw);
            }
            draw();
        })();

        // CANVAS 3
        (function(){
            const c = document.getElementById("netCanvas");
            const ctx = c.getContext("2d");
            function resize(){ c.width = innerWidth; c.height = innerHeight; }
            resize(); addEventListener("resize", resize);
            const dots = []; const count = 90;
            for(let i=0;i<count;i++){
                dots.push({ x:Math.random()*c.width, y:Math.random()*c.height,
                    vx:(Math.random()-0.5)*0.6, vy:(Math.random()-0.5)*0.6 });
            }
            function draw(){
                ctx.clearRect(0,0,c.width,c.height);
                dots.forEach(d=>{
                    d.x+=d.vx; d.y+=d.vy;
                    if(d.x<0||d.x>c.width)d.vx*=-1;
                    if(d.y<0||d.y>c.height)d.vy*=-1;
                    ctx.fillStyle="rgba(0,170,255,0.55)";
                    ctx.beginPath(); ctx.arc(d.x,d.y,2,0,Math.PI*2); ctx.fill();
                });
                for(let i=0;i<count;i++){
                    for(let j=i+1;j<count;j++){
                        const dx=dots[i].x-dots[j].x;
                        const dy=dots[i].y-dots[j].y;
                        const dist=Math.sqrt(dx*dx+dy*dy);
                        if(dist<130){
                            ctx.strokeStyle = `rgba(0,170,255,${0.12 - (dist/130)*0.12})`;
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(dots[i].x, dots[i].y);
                            ctx.lineTo(dots[j].x, dots[j].y);
                            ctx.stroke();
                        }
                    }
                }
                requestAnimationFrame(draw);
            }
            draw();
        })();
    </script>

    <div class="app">
        <header>
            <h1>Unidad 2</h1>
            <h2>Lista de actividades</h2>
        </header>

        <div class="grid-wrap">
            <div class="grid" id="activitiesGrid"></div>
        </div>

        <div class="footer-small">¬© 2025 - LUIS ANGEL QUENAYA LOZA</div>
    </div>

    <div class="detail-screen" id="detailScreen" aria-hidden="true">
        <div class="detail-inner">
            <div class="detail-head">
                <h2 id="detailTitle">Actividad</h2>
                <div class="controls">
                    <button class="btn" id="openPdfBtn">üìò Ver PDF</button> 
                    <button class="btn secondary" id="downloadCodeBtn" style="display: none;">üíæ Descargar c√≥digo</button>
                    <button class="btn ghost" id="closeDetailBtn">üîô Volver</button>
                </div>
            </div>

            <div class="content-columns">
                <div>
                    <h3 style="color:var(--azul-1);margin:12px 0 6px 0">üß© Enunciado</h3>
                    <div class="enunciado" id="detailEnunciado"></div> 

                    <div id="codeSection" style="display:none;">
                         <h3 style="color:var(--azul-1);margin:14px 0 6px 0">üíª C√≥digo de ejemplo</h3>
                        <pre class="code"><code id="detailCode"></code></pre>
                    </div>
                </div>

                <aside>
                    <div class="meta-card">
                        <p><strong>Facultad:</strong> FINESI</p>
                        <p><strong>Materia:</strong> Programaci√≥n Num√©rica</p>
                        <p><strong>Fecha entrega:</strong> 21/10/2025</p>
                    </div>
                </aside>
            </div>
        </div>
    </div>

    <div class="volver-floating" id="floatingBack" style="display:none">
        <button class="btn ghost" id="floatingClose">üîô Volver</button>
    </div>

    <a id="downloadAnchor" style="display:none"></a>

<script>
// =========================================================
// ARRAY DE ACTIVIDADES (A1 a A12)
// =========================================================

const activities = [
    { 
        id: 'a1',
        title: 'Actividad 1 ‚Äî M√©todo de Bisecci√≥n',
        pdf: 'BISECCION.pdf',
        description: `
            <p>El m√©todo de bisecci√≥n es un procedimiento iterativo para aproximar las **ra√≠ces** de una funci√≥n continua $f(x)$. Se basa en el **Teorema de Bolzano**, que indica que si $f(a) \\cdot f(b) < 0$ en un intervalo $[a, b]$, existe al menos una ra√≠z dentro del intervalo.</p>

            <p>El m√©todo consiste en dividir el intervalo a la mitad y seleccionar el subintervalo donde la funci√≥n cambia de signo, repitiendo este proceso hasta alcanzar la tolerancia deseada.</p>
            
            <div class="formula">
                **F√≥rmula del punto medio para acotar la ra√≠z:**
                $$ x_m = \frac{a + b}{2} $$
            </div>

            <h4>Importancia de graficar la funci√≥n</h4>
            <p>Antes de iniciar, es **recomendable graficar** $f(x)$ para ubicar aproximadamente el intervalo donde la funci√≥n cambia de signo y elegir valores iniciales $a$ y $b$ adecuados.  </p>

            <h4>Ventajas y limitaciones</h4>
            <ul>
                <li>**Ventaja:** Siempre converge si la funci√≥n es continua y $f(a) \\cdot f(b) < 0$.</li>
                <li>**Ventaja:** Simple de implementar.</li>
                <li>**Limitaci√≥n:** Convergencia lineal (**m√°s lenta** que m√©todos como Secante o Newton-Raphson).</li>
                <li>**Limitaci√≥n:** Requiere que la funci√≥n cambie de signo en el intervalo.</li>
            </ul>
            
            <div class="formula">
                **Error absoluto (acotaci√≥n del intervalo):**
                $$ E=\frac{b-a}{2} $$
            </div>
        `,
        code: `
import numpy as np
import matplotlib.pyplot as plt

func_str = input("Ingrese la funci√≥n f(x): ")

def f(x):
    return eval(func_str, {"np": np, "x": x})

a = float(input("Ingrese el valor inicial a: "))
b = float(input("Ingrese el valor inicial b: "))

tol = 1e-6
max_iter = 100

print("\\nIter | a          | b          | xm         | f(xm)      | Error")
print("---------------------------------------------------------------")

for i in range(1, max_iter+1):
    xm = (a + b)/2
    fxm = f(xm)
    error = (b - a)/2
    print(f"{i:4d} | {a:10.6f} | {b:10.6f} | {xm:10.6f} | {fxm:10.6f} | {error:10.6f}")
    
    if abs(fxm) < tol or error < tol:
        raiz = xm
        print(f"\\nRa√≠z aproximada: {raiz:.6f} encontrada en {i} iteraciones")
        break
    
    if f(a)*fxm < 0:
        b = xm
    else:
        a = xm
else:
    print("\\nNo se alcanz√≥ la convergencia despu√©s del m√°ximo de iteraciones")

# C√≥digo de graficaci√≥n
margen = (b - a)*0.1
xmin = a - margen
xmax = b + margen
x = np.linspace(xmin, xmax, 400)
y = f(x)

plt.plot(x, y, label=f"f(x) = {func_str}")
plt.axhline(0, color='black', linestyle='--')
plt.axvline(raiz, color='red', linestyle='--', label=f"Ra√≠z \\u2248 {raiz:.6f}")
plt.title("M√©todo de Bisecci√≥n")
plt.xlabel("x")
plt.ylabel("f(x)")
plt.legend()
plt.grid(True)
plt.show()`
    },
   { 
        id: 'a2',
        title: 'Actividad 2 ‚Äî M√©todo de la Secante',
        pdf: 'Secante.pdf',
        description: `
            <p>El **m√©todo de la secante** es un procedimiento iterativo para aproximar las **ra√≠ces** de una funci√≥n continua $f(x)$. A diferencia de Newton-Raphson, **no necesita derivadas**, ya que la pendiente se estima usando dos puntos cercanos a la ra√≠z.</p>

            <p>Se basa en la idea de reemplazar la tangente por una **secante**, la l√≠nea que une los puntos $(x_{n-1}, f(x_{n-1}))$ y $(x_n, f(x_n))$. La intersecci√≥n de esta secante con el eje $x$ nos da la siguiente aproximaci√≥n:</p>
            
            <div class="formula">
                **F√≥rmula de la Secante:**
                $$ x_{n+1} = x_n - f(x_n) \frac{x_n - x_{n-1}}{f(x_n) - f(x_{n-1})} $$
            </div>
            
            

            <h4>Importancia de graficar la funci√≥n</h4>
            <p>Antes de iniciar, es recomendable **graficar** $f(x)$ para ubicar aproximadamente d√≥nde cruza el eje $x$ y elegir dos valores iniciales $x_0$ y $x_1$ **cercanos a la ra√≠z**, aumentando la probabilidad de convergencia.</p>

            <h4>Ventajas y limitaciones</h4>
            <ul>
                <li>**Ventaja:** No requiere derivadas anal√≠ticas.</li>
                <li>**Ventaja:** Puede ser m√°s r√°pida que el m√©todo de bisecci√≥n.</li>
                <li>**Ventaja:** Convergencia superlineal (m√°s r√°pida que la lineal) si los puntos iniciales son adecuados.</li>
                <li>**Limitaci√≥n:** Puede **divergir** si los puntos iniciales no se eligen bien.</li>
                <li>**Limitaci√≥n:** No garantiza convergencia si la funci√≥n no es continua o si la diferencia $f(x_n) - f(x_{n-1})$ es cercana a cero.</li>
            </ul>
        `,
        code: `
import numpy as np
import matplotlib.pyplot as plt

# === 1. Ingreso de la funci√≥n ===
func_str = input("Ingrese la funci√≥n f(x): ")

# Definir la funci√≥n
def f(x):
    return eval(func_str, {"np": np, "x": x})

# === 2. Graficar la funci√≥n ===
xmin = float(input("Ingrese el valor m√≠nimo de x: "))
xmax = float(input("Ingrese el valor m√°ximo de x: "))

x = np.linspace(xmin, xmax, 400)
y = f(x)

plt.figure(figsize=(8, 5))
plt.plot(x, y, label=f"f(x) = {func_str}", color='blue')
plt.axhline(0, color='black', linestyle='--')
plt.axvline(0, color='black', linestyle='--')
plt.title("Gr√°fico de la funci√≥n ingresada")
plt.xlabel("x")
plt.ylabel("f(x)")
plt.legend()
plt.grid(True)
plt.show()


op = input("\\u00BFS\\u00ED o No? (s/n): ").lower()

if op == "s":
    # === 4. Ingreso de puntos iniciales ===
    x0 = float(input("Ingrese el primer valor inicial x0: "))
    x1 = float(input("Ingrese el segundo valor inicial x1: "))

    tol = 1e-6
    max_iter = 100

    print("\\nIteraci\\u00F3n |      x0     |      x1     |    f(x0)    |    f(x1)    |      x2     |    Error")
    print("-----------------------------------------------------------------------------------------")

    for i in range(1, max_iter + 1):
        f0 = f(x0)
        f1 = f(x1)

        if f1 - f0 == 0:
            print(f"\\n\\u26A0\\uFE0F Divisi\\u00F3n por cero en la iteraci\\u00F3n {i}. El m\\u00E9todo no puede continuar.")
            break

        # F\\u00F3rmula de la Secante
        x2 = x1 - f1 * (x1 - x0) / (f1 - f0)
        error = abs(x2 - x1)

        print(f"{i:9d} | {x0:11.6f} | {x1:11.6f} | {f0:11.6f} | {f1:11.6f} | {x2:11.6f} | {error:10.6f}")

        if error < tol:
            print(f"\\n\\u2705 Ra\\u00EDz aproximada encontrada: {x2:.6f}")
            print(f"Iteraciones realizadas: {i}")
            break

        x0, x1 = x1, x2

    else:
        print("\\n\\u26A0\\uFE0F No se alcanz\\u00F3 la convergencia despu\\u00E9s de", max_iter, "iteraciones.")
else:
    print("No se aplic\\u00F3 el m\\u00E9todo de la Secante.")
`
    },
  { 
        id: 'a3',
        title: 'Actividad 3 ‚Äî M√©todo del Punto Fijo',
        pdf: 'Puntofijo.pdf',
        description: `
            <p>El **M√©todo del Punto Fijo** es un procedimiento iterativo para aproximar las **ra√≠ces** de una ecuaci√≥n $f(x)=0$. Consiste en transformar la ecuaci√≥n original en una forma equivalente $x=g(x)$, donde $g(x)$ es llamada la **funci√≥n de iteraci√≥n**.</p>
            
            <p>El m√©todo genera una sucesi√≥n de aproximaciones mediante la siguiente f√≥rmula, partiendo de un valor inicial $x_0$. Si la sucesi√≥n converge a un valor $r$, entonces $r$ es un **punto fijo** de $g(x)$, y por tanto es la ra√≠z de $f(x)=0$.</p>

            <div class="formula">
                **F√≥rmula de iteraci√≥n:**
                $$ x_{n+1} = g(x_n) $$
            </div>
            
            

            <h4>Condici√≥n de Convergencia (Teorema del Punto Fijo)</h4>
            <p>Para que el m√©todo converja, la funci√≥n $g(x)$ debe cumplir el Teorema del Punto Fijo, donde la condici√≥n m√°s cr√≠tica es:</p>
            <ul>
                <li>$g(x)$ debe ser continua en un intervalo $[a, b]$.</li>
                <li>$g(x) \\in [a, b]$ para todo $x \\in [a, b]$ (El intervalo se mapea en s√≠ mismo).</li>
                <li>**Condici√≥n Clave:** Existe una constante $k < 1$ tal que la derivada cumple:</li>
            </ul>

            <div class="formula">
                **Condici√≥n de convergencia:**
                $$ |g'(x)| \\le k < 1 $$
            </div>

            <p>Si estas condiciones se cumplen, el m√©todo converge a la ra√≠z √∫nica en el intervalo.</p>

            <h4>Ventajas y limitaciones</h4>
            <ul>
                <li>**Ventaja:** M√©todo simple y f√°cil de implementar.</li>
                <li>**Ventaja:** No requiere el c√°lculo de derivadas de la funci√≥n original $f(x)$.</li>
                <li>**Ventaja:** √ötil cuando es f√°cil despejar $x$ de la ecuaci√≥n original.</li>
                <li>**Limitaci√≥n:** La convergencia depende fuertemente de la elecci√≥n de la funci√≥n $g(x)$.</li>
                <li>**Limitaci√≥n:** Puede **divergir** si $|g'(x)| \\ge 1$ cerca de la ra√≠z.</li>
                <li>**Limitaci√≥n:** La velocidad de convergencia es **lineal** (m√°s lenta que m√©todos como Newton-Raphson).</li>
            </ul>
        `,
        code: `
import numpy as np
import matplotlib.pyplot as plt

print("=== M\\u00C9TODO DEL PUNTO FIJO ===")

func_str = input("f(x) = ")
g_str = input("g(x) = ")

def f(x):
    return eval(func_str, {"np": np, "x": x})

def g(x):
    return eval(g_str, {"np": np, "x": x})

xmin = float(input("x m\\u00EDn: "))
xmax = float(input("x m\\u00E1x: "))

x = np.linspace(xmin, xmax, 400)
y = f(x)

plt.plot(x, y, label=f"f(x)={func_str}", color='blue')
plt.axhline(0, color='black', linestyle='--')
plt.axvline(0, color='black', linestyle='--')
plt.legend()
plt.grid(True)
plt.show(block=False)

x0 = float(input("x0 = "))
tol = 1e-6
max_iter = 100

print("\\nIter |       x_n      |      g(x_n)    |   f(g(x_n))    |     Error")
print("--------------------------------------------------------------------")

for i in range(1, max_iter + 1):
    x1 = g(x0)
    err = abs(x1 - x0)
    fx1 = f(x1)
    print(f"{i:4d} | {x0:14.8f} | {x1:14.8f} | {fx1:14.8f} | {err:10.8f}")
    if err < tol:
        print(f"\\nRa\\u00EDz \\u2248 {x1:.8f}")
        break
    x0 = x1
else:
    print("\\nNo se alcanz\\u00F3 la convergencia despu\\u00E9s del m\\u00E1ximo de iteraciones")
`
    },
    { 
        id: 'a4',
        title: 'Actividad 4 ‚Äî M√©todo de Regula Falsi',
        pdf: 'Regulafalsi.pdf',
        description: `
            <p>El **m√©todo de Regula Falsi** (o **Falsa Posici√≥n**) es un procedimiento iterativo para aproximar **ra√≠ces** de una funci√≥n continua $f(x)$. Al igual que el m√©todo de bisecci√≥n, requiere que $f(a) \\cdot f(b) < 0$ para acotar la ra√≠z.</p>

            <p>En lugar de usar el punto medio, se utiliza la intersecci√≥n con el eje $x$ de la **recta secante** que une los puntos $(a, f(a))$ y $(b, f(b))$. Esto proporciona una mejor aproximaci√≥n en la mayor√≠a de los casos.</p>
            
            <div class="formula">
                **F√≥rmula de Regula Falsi:**
                $$ x_r = b - f(b)\frac{b-a}{f(b)-f(a)} $$
            </div>

            
            
            <h4>Importancia de graficar la funci√≥n</h4>
            <p>Antes de iniciar, es recomendable **graficar** $f(x)$ para ubicar el intervalo donde la funci√≥n cambia de signo y elegir los valores iniciales $a$ y $b$ que acoten la ra√≠z.</p>

            <h4>Ventajas y limitaciones</h4>
            <ul>
                <li>**Ventaja:** Converge m√°s r√°pido que el m√©todo de bisecci√≥n en muchos casos.</li>
                <li>**Ventaja:** Utiliza informaci√≥n de la pendiente aproximada entre los extremos, mejorando la estimaci√≥n.</li>
                <li>**Limitaci√≥n:** Requiere que la funci√≥n cambie de signo en el intervalo.</li>
                <li>**Limitaci√≥n:** Puede experimentar **convergencia lenta** (estancamiento) si la funci√≥n es muy c√≥ncava o convexa cerca de la ra√≠z y uno de los extremos se queda fijo.</li>
            </ul>
        `,
        code: `
import numpy as np
import matplotlib.pyplot as plt

func_str = input("Ingrese la funci√≥n f(x): ")

def f(x):
    return eval(func_str, {"np": np, "x": x})

a = float(input("Ingrese el valor inicial a: "))
b = float(input("Ingrese el valor inicial b: "))

if f(a) * f(b) >= 0:
    print("Error: f(a) y f(b) deben tener signos opuestos.")
else:
    tol = 1e-6
    max_iter = 100
    raiz = None

    print("\\nIter | a          | b          | xr         | f(xr)      | Error")
    print("---------------------------------------------------------------")

    for i in range(1, max_iter+1):
        fa = f(a)
        fb = f(b)
        
        # F\\u00F3rmula de Regula Falsi
        xr = b - fb * (b - a) / (fb - fa)
        fxr = f(xr)
        error = abs(fxr)
        
        print(f"{i:4d} | {a:10.6f} | {b:10.6f} | {xr:10.6f} | {fxr:10.6f} | {error:10.6f}")
        
        if abs(fxr) < tol:
            raiz = xr
            print(f"\\nRa\\u00EDz aproximada: {raiz:.6f} encontrada en {i} iteraciones")
            break
        
        if fa * fxr < 0:
            b = xr
        else:
            a = xr
    else:
        print("\\nNo se alcanz\\u00F3 la convergencia despu\\u00E9s del m\\u00E1ximo de iteraciones")

    # C\\u00F3digo de graficaci\\u00F3n
    if raiz is not None:
        # Ajuste de margen para la gr\\u00E1fica
        margen = 0.1 * (max(b, raiz) - min(a, raiz)) if raiz else 0.1 * (b - a)
        xmin = min(a,b,raiz) - margen
        xmax = max(a,b,raiz) + margen
        x = np.linspace(xmin, xmax, 400)
        y = f(x)

        plt.plot(x, y, label=f"f(x) = {func_str}")
        plt.axhline(0, color='black', linestyle='--')
        plt.axvline(raiz, color='red', linestyle='--', label=f"Ra\\u00EDz \\u2248 {raiz:.6f}")
        plt.title("M\\u00E9todo de Regula Falsi")
        plt.xlabel("x")
        plt.ylabel("f(x)")
        plt.legend()
        plt.grid(True)
        plt.show()`
    },
   { 
        id: 'a5',
        title: 'Actividad 5 ‚Äî M√©todo de Newton-Raphson',
        pdf: 'Actividad_05.pdf',
        description: `
            <h4>Descripci√≥n</h4>
            <p>El **m√©todo de Newton-Raphson** es un procedimiento iterativo que permite obtener una aproximaci√≥n de las ra√≠ces reales de una funci√≥n continua y derivable. Su fundamento se basa en usar la **recta tangente** a la funci√≥n en el punto actual $x_n$ para estimar el siguiente punto $x_{n+1}$.</p>
            <p>Matem√°ticamente, se deriva del desarrollo del polinomio de **Taylor de primer orden** alrededor de un punto inicial $x_0$.</p>

            
            
            <div class="formula">
                **F√≥rmula de Newton-Raphson (Recursiva):**
                $$ x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)} $$
            </div>

            <p>En cada iteraci√≥n se utiliza la pendiente de la tangente $f'(x_n)$ en el punto $x_n$ para aproximarse progresivamente a la ra√≠z. Si la funci√≥n y su derivada son continuas, y el punto inicial est√° cerca de la ra√≠z, la convergencia es **cuadr√°tica** (muy r√°pida).</p>

            <h4>Importancia de la visualizaci√≥n</h4>
            <p>Antes de aplicar el m√©todo, es recomendable **graficar** la funci√≥n $f(x)$ en un intervalo adecuado. Esto permite identificar las zonas donde cruza el eje $x$, estimar una ra√≠z posible y elegir un valor inicial $x_0$ apropiado, lo que incrementa las probabilidades de que el m√©todo converja correctamente.</p>

            <h4>Restricciones y limitaciones</h4>
            <ul>
                <li>**Restricci√≥n Cr√≠tica:** No se debe aplicar cuando la derivada $f'(x_n)$ es cero o muy cercana a cero, ya que genera una indeterminaci√≥n (divisi√≥n por cero).</li>
                <li>Si el punto inicial est√° lejos de la ra√≠z, la **convergencia no est√° garantizada** (puede divergir o converger a otra ra√≠z).</li>
                <li>En ra√≠ces m√∫ltiples, la convergencia puede ser lenta o inestable.</li>
                <li>Se requiere que tanto $f(x)$ como $f'(x)$ sean continuas cerca de la ra√≠z buscada.</li>
            </ul>
        `,
        code: `
import numpy as np
import matplotlib.pyplot as plt
import time

ecuacion = input("Ingrese la funci\\u00F3n f(x): ")

def f(x):
    # Usamos eval de forma controlada para ejecutar la funci\\u00F3n
    return eval(ecuacion, {"np": np, "__builtins__": None, "x": x})

def derivada(x):
    # Aproximaci\\u00F3n num\\u00E9rica de la derivada por diferencia central
    h = 1e-6
    return (f(x + h) - f(x - h)) / (2 * h)

a = float(input("Ingrese el l\\u00EDmite inferior del eje x: "))
b = float(input("Ingrese el l\\u00EDmite superior del eje x: "))

x_vals = np.linspace(a, b, 400)
y_vals = f(x_vals)

plt.figure(figsize=(8, 5))
plt.plot(x_vals, y_vals, 'b', label=f"f(x) = {ecuacion}")
plt.axhline(0, color='black', linestyle='--')
plt.axvline(0, color='black', linestyle='--')
plt.title("Gr\\u00E1fico de la funci\\u00F3n ingresada")
plt.xlabel("x")
plt.ylabel("f(x)")
plt.legend()
plt.grid(True)
plt.show(block=False)
time.sleep(3)
plt.close()

x = float(input("Ingrese el valor inicial aproximado: "))
tolerancia = 1e-6
iter_max = 100

print("\\nIter | x_n         | f(x_n)      | f'(x_n)     | Error")
print("--------------------------------------------------------------------")

for i in range(iter_max):
    fx = f(x)
    dfx = derivada(x)
    
    if abs(dfx) < 1e-10: # Cuidado con la divisi\\u00F3n por cero
        print(f"La derivada es cero en x = {x:.6f}. No se puede continuar.")
        break
        
    x_nuevo = x - fx / dfx
    error = abs(x_nuevo - x)
    
    print(f"{i+1:4d} | {x:11.6f} | {fx:11.6f} | {dfx:11.6f} | {error:8.6f}")

    if error < tolerancia:
        print(f"\\nRa\\u00EDz encontrada: {x_nuevo:.6f}")
        print(f"N\\u00FAmero de iteraciones: {i + 1}")
        break
        
    x = x_nuevo
else:
    print(f"\\nNo se logr\\u00F3 la convergencia despu\\u00E9s de {iter_max} iteraciones.")
    print(f"\\u00DAltimo valor aproximado: {x:.6f}")
`
    },
    { 
        id: 'a6',
        title: 'Actividad 6 ‚Äî √çndice H ',
        pdf: 'Actividad6.pdf',
        description: `
            <p>El **√çndice H** (o √≠ndice de Hirsch) mide la productividad y el impacto de un investigador. Un autor tiene un √≠ndice H de $h$ si $h$ de sus $N_p$ publicaciones tienen al menos $h$ citas cada una, y las $(N_p - h)$ publicaciones restantes tienen un m√°ximo de $h$ citas cada una.</p>
            
            <h4>C√°lculo del √çndice H (Algoritmo)</h4>
            <p>Para calcular el √≠ndice H de un conjunto de publicaciones con un n√∫mero de citas dado:</p>
            <ol>
                <li>Ordenar la lista de citas en orden **descendente** (de mayor a menor).</li>
                <li>Iterar sobre la lista ordenada. Si el n√∫mero de citas de la publicaci√≥n $i$ (donde $i$ es la posici√≥n, empezando en 1) es **mayor o igual** a $i$, entonces el √≠ndice H es al menos $i$.</li>
                <li>El valor m√°ximo de $i$ que cumple la condici√≥n es el √≠ndice H.</li>
            </ol>
            
            <h4>Ejemplo de c√°lculo</h4>
            <table class="activity-table">
                <thead>
                    <tr>
                        <th>Posici√≥n (i)</th>
                        <th>Citas (orden descendente)</th>
                        <th>Citas $\ge$ Posici√≥n (i)?</th>
                        <th>√çndice H</th>
                    </tr>
                </thead>
                <tbody>
                    <tr><td>1</td><td>10</td><td>$10 \ge 1$ (S√≠)</td><td>1</td></tr>
                    <tr><td>2</td><td>8</td><td>$8 \ge 2$ (S√≠)</td><td>2</td></tr>
                    <tr><td>3</td><td>5</td><td>$5 \ge 3$ (S√≠)</td><td>3</td></tr>
                    <tr><td>4</td><td>4</td><td>$4 \ge 4$ (S√≠)</td><td>4</td></tr>
                    <tr><td>5</td><td>3</td><td>$3 \ge 5$ (No)</td><td>4 (final)</td></tr>
                </tbody>
            </table>
            <p>En este ejemplo, el **√çndice H es 4**. Significa que 4 de las publicaciones tienen al menos 4 citas.</p>
        `,
        code: `
import numpy as np

def calcular_indice_h(citas):
    """Calcula el √≠ndice H de una lista de citas."""
    # 1. Convertir a un array de numpy (opcional, pero √∫til)
    citas_np = np.array(citas)
    
    # 2. Ordenar las citas en orden descendente
    citas_ordenadas = np.sort(citas_np)[::-1]
    
    n = len(citas_ordenadas)
    indice_h = 0
    
    # 3. Iterar sobre la lista ordenada
    for i in range(n):
        # i + 1 es el valor de 'h' (la posici\\u00F3n, empezando en 1)
        h = i + 1 
        
        # Condici\\u00F3n: El n\\u00FAmero de citas debe ser mayor o igual a la posici\\u00F3n
        if citas_ordenadas[i] >= h:
            indice_h = h # El \\u00EDndice H es al menos 'h'
        else:
            # Si no cumple, el m\\u00E1ximo \\u00EDndice H ya fue encontrado
            break 
            
    return indice_h

# EJEMPLO DE USO
citas_input = input("Ingrese las citas separadas por comas (ej: 10,8,5,4,3): ")
try:
    citas_lista = [int(x.strip()) for x in citas_input.split(',')]
    
    if not citas_lista:
        print("No se ingresaron citas v\\u00E1lidas.")
    else:
        h_index = calcular_indice_h(citas_lista)
        print("\\nCitas ingresadas (ordenadas):", np.sort(np.array(citas_lista))[::-1])
        print(f"\\u2705 El \\u00CDndice H es: {h_index}")

except ValueError:
    print("\\u26A0\\uFE0F Error: Aseg\\u00FArese de ingresar solo n\\u00FAmeros enteros separados por comas.")

`
    },
    // =========================================================
    // NUEVAS ACTIVIDADES (7 a 12)
    // =========================================================
    {
        id: 'a7',
        title: 'Actividad 7 ‚Äî Integraci√≥n: Regla del Trapecio',
        pdf: 'ReglaTrapecio.pdf',
        description: `
            <p>La **Regla del Trapecio** es un m√©todo de integraci√≥n num√©rica que se utiliza para aproximar el valor de una integral definida $\int_{a}^{b} f(x) dx$. Se basa en aproximar el √°rea bajo la curva de la funci√≥n $f(x)$ mediante el √°rea de un **trapecio**.</p>
            
            <p>Si el intervalo $[a, b]$ se divide en un solo trapecio, la f√≥rmula es:</p>
            
            <div class="formula">
                **Regla del Trapecio (Simple):**
                $$ \int_{a}^{b} f(x) dx \approx \frac{b - a}{2} [f(a) + f(b)] $$
            </div>
            
            <p>Para aumentar la precisi√≥n, se utiliza la **Regla del Trapecio Compuesta**, donde el intervalo se divide en $n$ subintervalos de ancho $h = (b-a)/n$, y se suman las √°reas de los $n$ trapecios.</p>
            
            <div class="formula">
                **Regla del Trapecio (Compuesta):**
                $$ \int_{a}^{b} f(x) dx \approx \frac{h}{2} [f(x_0) + 2\sum_{i=1}^{n-1} f(x_i) + f(x_n)] $$
            </div>
            
            <h4>Error de Truncamiento</h4>
            <p>El error en la regla del trapecio es proporcional al cuadrado del ancho del subintervalo $h^2$. Al aumentar el n√∫mero de subintervalos ($n$), se reduce el error, pero se aumenta el costo computacional.</p>
        `,
        code: `
import numpy as np

func_str = input("Ingrese la funci√≥n f(x): ")

def f(x):
    return eval(func_str, {"np": np, "x": x})

a = float(input("L√≠mite inferior (a): "))
b = float(input("L√≠mite superior (b): "))
n = int(input("N√∫mero de subintervalos (n): "))

if n <= 0:
    print("El n√∫mero de subintervalos debe ser positivo.")
else:
    h = (b - a) / n
    sumatoria = 0
    
    # Suma de los t√©rminos intermedios (multiplicados por 2)
    for i in range(1, n):
        x_i = a + i * h
        sumatoria += 2 * f(x_i)
        
    # Sumar los extremos (f(a) y f(b))
    integral = (h / 2) * (f(a) + sumatoria + f(b))
    
    print(f"\\nAncho del subintervalo (h): {h:.6f}")
    print(f"\\u2705 Aproximaci√≥n de la integral: {integral:.8f}")
`
    },
    {
        id: 'a8',
        title: 'Actividad 8 ‚Äî Integraci√≥n: Regla de Simpson 1/3',
        pdf: 'ReglaSimpson.pdf',
        description: `
            <p>La **Regla de Simpson 1/3** es otro m√©todo de integraci√≥n num√©rica m√°s preciso que el Trapecio. En lugar de aproximar la funci√≥n con una l√≠nea recta (grado 1), utiliza un **polinomio de grado 2** (una par√°bola) para aproximar la funci√≥n en dos subintervalos.</p>
            
            <p>Este m√©todo requiere que el n√∫mero de subintervalos ($n$) sea **par**. Para un solo segmento (dos subintervalos), la f√≥rmula es:</p>
            
            <div class="formula">
                **Regla de Simpson 1/3 (Simple, n=2):**
                $$ \int_{x_0}^{x_2} f(x) dx \approx \frac{h}{3} [f(x_0) + 4f(x_1) + f(x_2)] $$
            </div>
            
            <p>Para la **Regla Compuesta**, se aplica la f√≥rmula a todos los pares de subintervalos:</p>
            
            <div class="formula">
                **Regla de Simpson 1/3 (Compuesta, n par):**
                $$ \int_{a}^{b} f(x) dx \approx \frac{h}{3} [f(x_0) + 4\sum_{i \text{ impar}}^{n-1} f(x_i) + 2\sum_{i \text{ par}}^{n-2} f(x_i) + f(x_n)] $$
            </div>
            
            <h4>Ventaja de Convergencia</h4>
            <p>El error de truncamiento en Simpson 1/3 es proporcional a $h^4$, lo que significa que la precisi√≥n aumenta mucho m√°s r√°pido que con el m√©todo del trapecio al disminuir $h$.</p>
        `,
        code: `
import numpy as np

func_str = input("Ingrese la funci√≥n f(x): ")

def f(x):
    return eval(func_str, {"np": np, "x": x})

a = float(input("L√≠mite inferior (a): "))
b = float(input("L√≠mite superior (b): "))
n = int(input("N√∫mero de subintervalos (n, debe ser PAR): "))

if n <= 0 or n % 2 != 0:
    print("El n√∫mero de subintervalos (n) debe ser un n√∫mero PAR y positivo.")
else:
    h = (b - a) / n
    suma_impares = 0 # Multiplicados por 4
    suma_pares = 0   # Multiplicados por 2
    
    # Sumar t√©rminos intermedios
    for i in range(1, n):
        x_i = a + i * h
        if i % 2 == 1:
            suma_impares += f(x_i)
        else:
            suma_pares += f(x_i)
            
    # F√≥rmula completa de Simpson 1/3
    integral = (h / 3) * (f(a) + 4 * suma_impares + 2 * suma_pares + f(b))
    
    print(f"\\nAncho del subintervalo (h): {h:.6f}")
    print(f"\\u2705 Aproximaci√≥n de la integral: {integral:.8f}")
`
    },
    {
        id: 'a9',
        title: 'Actividad 9 ‚Äî Derivaci√≥n Num√©rica: Diferencias Finitas',
        pdf: 'DerivacionNum.pdf',
        description: `
            <p>La **derivaci√≥n num√©rica** aproxima la pendiente de una funci√≥n $f(x)$ sin usar c√°lculo simb√≥lico. Se basa en el l√≠mite de la definici√≥n de la derivada:</p>
            
            <div class="formula">
                **Derivada (Definici√≥n L√≠mite):**
                $$ f'(x) = \lim_{h \to 0} \frac{f(x+h) - f(x)}{h} $$
            </div>
            
            <p>Los m√©todos m√°s comunes usan un valor finito de $h$ (paso) y se clasifican seg√∫n los puntos utilizados:</p>
            
            <h4>1. Diferencia Adelantada (Forward Difference)</h4>
            <p>Utiliza el punto actual $x$ y el siguiente $x+h$. Es de orden $O(h)$.</p>
            <div class="formula">
                $$ f'(x) \approx \frac{f(x+h) - f(x)}{h} $$
            </div>
            
            <h4>2. Diferencia Retrasada (Backward Difference)</h4>
            <p>Utiliza el punto actual $x$ y el anterior $x-h$. Es de orden $O(h)$.</p>
            <div class="formula">
                $$ f'(x) \approx \frac{f(x) - f(x-h)}{h} $$
            </div>
            
            <h4>3. Diferencia Central (Centered Difference)</h4>
            <p>Utiliza puntos a ambos lados ($x-h$ y $x+h$). Es la m√°s precisa, de orden $O(h^2)$.</p>
            <div class="formula">
                $$ f'(x) \approx \frac{f(x+h) - f(x-h)}{2h} $$
            </div>
            
            <p>El desaf√≠o es elegir un $h$ lo suficientemente peque√±o para reducir el error de truncamiento, pero no tan peque√±o que el error de redondeo (por la precisi√≥n limitada de la m√°quina) se vuelva significativo.</p>
        `,
        code: `
import numpy as np

func_str = input("Ingrese la funci√≥n f(x): ")
x_val = float(input("Ingrese el punto x donde calcular f'(x): "))
h = float(input("Ingrese el tama√±o del paso (h), ej: 0.001: "))

def f(x):
    return eval(func_str, {"np": np, "x": x})

# Diferencia Adelantada (O(h))
def forward_diff(x, h):
    return (f(x + h) - f(x)) / h

# Diferencia Retrasada (O(h))
def backward_diff(x, h):
    return (f(x) - f(x - h)) / h

# Diferencia Central (O(h^2))
def centered_diff(x, h):
    return (f(x + h) - f(x - h)) / (2 * h)

print("\\n--- Resultados de Derivaci√≥n Num√©rica ---")
print(f"Punto (x): {x_val}")
print(f"Paso (h): {h}")
print("------------------------------------------")
print(f"Adelantada (O(h)): {forward_diff(x_val, h):.8f}")
print(f"Retrasada (O(h)):  {backward_diff(x_val, h):.8f}")
print(f"Central (O(h¬≤)):   {centered_diff(x_val, h):.8f}")
`
    },
    {
        id: 'a10',
        title: 'Actividad 10 ‚Äî Eliminaci√≥n Gaussiana',
        pdf: 'Gauss.pdf',
        description: `
            <p>La **Eliminaci√≥n Gaussiana** es un m√©todo fundamental para resolver sistemas de ecuaciones lineales $AX=B$. El objetivo es transformar la matriz aumentada del sistema en una **matriz triangular superior** (proceso de eliminaci√≥n), y luego resolver el sistema mediante **sustituci√≥n hacia atr√°s**.</p>
            
            <h4>Proceso de Eliminaci√≥n</h4>
            <p>Se utilizan operaciones elementales por fila para introducir ceros debajo de la diagonal principal. Estas operaciones incluyen:</p>
            <ol>
                <li>Multiplicar una fila por una constante distinta de cero.</li>
                <li>Intercambiar dos filas.</li>
                <li>Sumar el m√∫ltiplo de una fila a otra fila.</li>
            </ol>
            <p>La matriz aumentada se transforma en una matriz de la forma:</p>
            <div class="formula">
                $$ \begin{bmatrix} a_{11} & a_{12} & \cdots & a_{1n} & | & b_1 \\ 0 & a'_{22} & \cdots & a'_{2n} & | & b'_2 \\ \vdots & \vdots & \ddots & \vdots & | & \vdots \\ 0 & 0 & \cdots & a''_{nn} & | & b''_n \end{bmatrix} $$
            </div>
            
            <h4>Sustituci√≥n hacia atr√°s</h4>
            <p>Una vez que se obtiene la matriz triangular, la √∫ltima ecuaci√≥n contiene solo una inc√≥gnita ($x_n$), la cual se resuelve. Luego, este valor se sustituye en la pen√∫ltima ecuaci√≥n para encontrar $x_{n-1}$, y as√≠ sucesivamente hasta encontrar $x_1$.</p>
            
            <h4>Pivoteo</h4>
            <p>Es crucial usar **pivoteo parcial** (intercambiar filas para poner el elemento m√°s grande de la columna debajo de la diagonal como pivote) para evitar la divisi√≥n por cero y reducir el error de redondeo.</p>
        `,
        code: `
import numpy as np

def eliminacion_gaussiana(A, B):
    # Convertir a matrices de numpy para facilitar el c\\u00E1lculo
    A = np.array(A, dtype=float)
    B = np.array(B, dtype=float)
    n = len(A)
    
    # Matriz aumentada [A|B]
    M = np.hstack((A, B.reshape(n, 1)))

    # --- FASE DE ELIMINACI\\u00D3N (Triangulaci\\u00F3n) ---
    for i in range(n):
        # Pivoteo (simple - encontrar el valor m\\u00E1ximo en la columna i)
        max_row = i
        for k in range(i + 1, n):
            if abs(M[k, i]) > abs(M[max_row, i]):
                max_row = k
        M[[i, max_row]] = M[[max_row, i]] # Intercambio de filas
        
        # Eliminaci\\u00F3n de la columna i
        for k in range(i + 1, n):
            if M[i, i] == 0:
                 # Manejo simple de singularidad
                raise ValueError("El sistema tiene soluciones infinitas o no tiene soluci\\u00F3n (matriz singular).")

            factor = M[k, i] / M[i, i]
            M[k, i:] = M[k, i:] - factor * M[i, i:]

    # --- FASE DE SUSTITUCI\\u00D3N HACIA ATR\\u00C1S ---
    X = np.zeros(n)
    for i in range(n - 1, -1, -1):
        # Sustituci\\u00F3n
        X[i] = (M[i, n] - np.dot(M[i, i+1:n], X[i+1:n])) / M[i, i]
        
    return X

# EJEMPLO DE USO:
# 2x + y - z = 8
# -3x - y + 2z = -11
# -2x + y + 2z = -3

A = [[2, 1, -1], [-3, -1, 2], [-2, 1, 2]]
B = [8, -11, -3]

try:
    solucion = eliminacion_gaussiana(A, B)
    print("\\nMatriz de Coeficientes (A):")
    print(np.array(A))
    print("\\nVector de T\\u00E9rminos Independientes (B):")
    print(np.array(B))
    print("\\n\\u2705 Soluci\\u00F3n del sistema (X):")
    print(solucion)
except ValueError as e:
    print(f"Error: {e}")
`
    },
    {
        id: 'a11',
        title: 'Actividad 11 ‚Äî M√©todo de Jacobi',
        pdf: 'Jacobi.pdf',
        description: `
            <p>El **M√©todo de Jacobi** es un m√©todo iterativo utilizado para resolver sistemas de ecuaciones lineales $AX=B$. Es una alternativa a los m√©todos directos (como Eliminaci√≥n Gaussiana), especialmente √∫til para **matrices grandes y dispersas**.</p>
            
            <h4>Condici√≥n de Convergencia</h4>
            <p>Una condici√≥n suficiente (pero no necesaria) para que el m√©todo de Jacobi converja es que la matriz $A$ sea **estrictamente dominante diagonalmente**. Esto significa que, para cada fila, el valor absoluto del elemento en la diagonal es mayor que la suma de los valores absolutos de los otros elementos en esa fila.</p>
            <div class="formula">
                **Dominancia Diagonal:**
                $$ |a_{ii}| > \sum_{j=1, j\neq i}^{n} |a_{ij}| \quad \text{para todo } i=1, \ldots, n $$
            </div>
            
            <h4>F√≥rmula de Iteraci√≥n</h4>
            <p>El sistema se reescribe despejando cada variable $x_i$ de la ecuaci√≥n $i$, utilizando las aproximaciones de las variables de la iteraci√≥n anterior $k$ para calcular la aproximaci√≥n actual $k+1$:</p>
            <div class="formula">
                $$ x_i^{(k+1)} = \frac{1}{a_{ii}} \left( b_i - \sum_{j=1, j\neq i}^{n} a_{ij} x_j^{(k)} \right) $$
            </div>
            
            <h4>Ventajas</h4>
            <ul>
                <li>F√°cil de implementar.</li>
                <li>Ideal para matrices grandes y dispersas.</li>
                <li>Se presta bien a la paralelizaci√≥n (los c√°lculos de cada $x_i$ son independientes).</li>
            </ul>
        `,
        code: `
import numpy as np

def metodo_jacobi(A, B, x0, tol=1e-5, max_iter=100):
    A = np.array(A, dtype=float)
    B = np.array(B, dtype=float)
    X = np.array(x0, dtype=float)
    n = len(A)
    
    X_nuevo = np.copy(X)
    
    print("Iter |  x1        |  x2        |  x3        | Error")
    print("-------------------------------------------------------")

    for k in range(1, max_iter + 1):
        X_ant = np.copy(X)
        
        # C\\u00E1lculo de la nueva iteraci\\u00F3n
        for i in range(n):
            suma = 0
            for j in range(n):
                if i != j:
                    suma += A[i, j] * X_ant[j]
            
            if A[i, i] == 0:
                raise ValueError("Divisi\\u00F3n por cero. El m\\u00E9todo de Jacobi no puede continuar.")

            X_nuevo[i] = (B[i] - suma) / A[i, i]
        
        error = np.linalg.norm(X_nuevo - X_ant) # Error euclidiano
        X = np.copy(X_nuevo)
        
        print(f"{k:4d} | {X[0]:10.6f} | {X[1]:10.6f} | {X[2]:10.6f} | {error:8.6e}")
        
        if error < tol:
            print(f"\\n\\u2705 Convergencia alcanzada en {k} iteraciones.")
            return X
            
    print(f"\\n\\u26A0\\uFE0F No se alcanz\\u00F3 la convergencia despu\\u00E9s de {max_iter} iteraciones.")
    return X

# EJEMPLO (Dominante Diagonalmente):
# 4x1 - x2 + 0x3 = 8
# -2x1 + 5x2 + x3 = 10
# 0x1 - x2 + 3x3 = 6
A = [[4, -1, 0], [-2, 5, 1], [0, -1, 3]]
B = [8, 10, 6]
x0 = [0, 0, 0] # Vector inicial

try:
    solucion = metodo_jacobi(A, B, x0)
    print("\\nSoluci\\u00F3n aproximada:", solucion)
except ValueError as e:
    print(f"Error: {e}")
`
    },
    {
        id: 'a12',
        title: 'Actividad 12 ‚Äî Regresi√≥n Lineal (M√≠nimos Cuadrados)',
        pdf: 'MinimosCuadrados.pdf',
        description: `
            <p>La **Regresi√≥n Lineal por M√≠nimos Cuadrados** es el m√©todo m√°s com√∫n para ajustar una l√≠nea recta $y = mx + b$ a un conjunto de datos $(x_i, y_i)$. El objetivo es encontrar la pendiente ($m$) y la intersecci√≥n ($b$) que **minimizan la suma de los cuadrados** de los residuos (la distancia vertical entre cada punto de datos y la l√≠nea ajustada).</p>
            
            <p>La funci√≥n a minimizar es $S_r = \sum_{i=1}^{n} (y_i - (mx_i + b))^2$. Derivando $S_r$ con respecto a $m$ y $b$ e igualando a cero, se obtienen las siguientes **ecuaciones normales**:</p>
            
            <div class="formula">
                **Pendiente (m):**
                $$ m = \frac{n \sum (x_i y_i) - \sum x_i \sum y_i}{n \sum x_i^2 - (\sum x_i)^2} $$
            </div>
            
            <div class="formula">
                **Intersecci√≥n (b):**
                $$ b = \bar{y} - m\bar{x} $$
                <p>Donde $\bar{x}$ y $\bar{y}$ son las medias de los datos $x$ e $y$, respectivamente.</p>
            </div>
            
            <h4>Coeficiente de Determinaci√≥n ($R^2$)</h4>
            <p>Este valor mide qu√© tan bien la l√≠nea de regresi√≥n se ajusta a los datos, donde $R^2=1$ indica un ajuste perfecto.</p>
        `,
        code: `
import numpy as np
import matplotlib.pyplot as plt

# Ingreso de datos
print("Ingrese los datos x e y separados por comas y espacio (ej: 1,2,3 4,5,6)")
try:
    x_str = input("Valores de X: ")
    y_str = input("Valores de Y: ")
    
    X = np.array([float(val.strip()) for val in x_str.split(',')])
    Y = np.array([float(val.strip()) for val in y_str.split(',')])

    n = len(X)
    if n != len(Y) or n < 2:
        raise ValueError("El n\\u00FAmero de datos X e Y debe ser igual y mayor a 1.")

    # C\\u00E1lculos de las sumatorias
    sum_x = np.sum(X)
    sum_y = np.sum(Y)
    sum_xy = np.sum(X * Y)
    sum_x2 = np.sum(X**2)

    # 1. C\\u00E1lculo de la pendiente (m)
    numerador_m = n * sum_xy - sum_x * sum_y
    denominador_m = n * sum_x2 - sum_x**2
    
    if denominador_m == 0:
        raise ValueError("Error: El denominador para 'm' es cero (todos los valores de X son iguales).")

    m = numerador_m / denominador_m

    # 2. C\\u00E1lculo de la intersecci\\u00F3n (b)
    prom_x = sum_x / n
    prom_y = sum_y / n
    b = prom_y - m * prom_x

    # 3. Funci\\u00F3n de la l\\u00EDnea ajustada
    def linea_ajustada(x):
        return m * x + b
        
    print(f"\\n\\u2705 Ecuaci\\u00F3n de la recta de regresi\\u00F3n:")
    print(f"Y = {m:.4f} * X + {b:.4f}")

    # C\\u00F3digo de graficaci\\u00F3n
    x_line = np.linspace(np.min(X) - 1, np.max(X) + 1, 100)
    y_line = linea_ajustada(x_line)

    plt.figure(figsize=(8, 5))
    plt.scatter(X, Y, color='blue', label='Datos Originales')
    plt.plot(x_line, y_line, color='red', label=f'Regresi√≥n: Y = {m:.2f}x + {b:.2f}')
    plt.title('Regresi√≥n Lineal por M√≠nimos Cuadrados')
    plt.xlabel('X')
    plt.ylabel('Y')
    plt.legend()
    plt.grid(True)
    plt.show()

except ValueError as e:
    print(f"\\u26A0\\uFE0F Error en los datos: {e}")
`
    }
];

// =========================================================
// L√ìGICA DE RENDERIZADO Y FUNCIONALIDAD
// =========================================================

const detailScreen = document.getElementById('detailScreen');
const gridContainer = document.getElementById('activitiesGrid');
const detailTitle = document.getElementById('detailTitle');
const detailEnunciado = document.getElementById('detailEnunciado');
const detailCode = document.getElementById('detailCode');
const codeSection = document.getElementById('codeSection');
const openPdfBtn = document.getElementById('openPdfBtn');
const downloadCodeBtn = document.getElementById('downloadCodeBtn');
const downloadAnchor = document.getElementById('downloadAnchor');
const floatingBack = document.getElementById('floatingBack');

// 1. Dibuja las tarjetas en el grid
function renderActivities() {
    gridContainer.innerHTML = '';
    activities.forEach(activity => {
        const card = document.createElement('div');
        card.className = 'card';
        card.setAttribute('data-id', activity.id);

        // Tomar la primera parte de la descripci√≥n para el p√°rrafo de la tarjeta
        // Primero, limpia etiquetas HTML para obtener solo texto
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = activity.description;
        const shortText = tempDiv.textContent || tempDiv.innerText || "";
        
        const shortDesc = shortText.substring(0, 150) + '...';

        card.innerHTML = `
            <h3>${activity.title}</h3>
            <p>${shortDesc}</p>
        `;
        
        card.addEventListener('click', () => showDetail(activity.id));
        gridContainer.appendChild(card);
    });
}

// 2. Muestra la pantalla de detalles de una actividad
function showDetail(id) {
    const activity = activities.find(a => a.id === id);
    if (!activity) return;

    // Actualizar contenido de la pantalla de detalles
    detailTitle.textContent = activity.title;
    detailEnunciado.innerHTML = activity.description;
    
    // Mostrar u ocultar secci√≥n de c√≥digo
    if (activity.code) {
        detailCode.textContent = activity.code;
        codeSection.style.display = 'block';
        downloadCodeBtn.style.display = 'inline-block';
        downloadCodeBtn.onclick = () => downloadCode(activity.code, activity.title.split('‚Äî')[0].trim());
    } else {
        codeSection.style.display = 'none';
        downloadCodeBtn.style.display = 'none';
    }

    // Bot√≥n de PDF
    openPdfBtn.onclick = () => window.open(activity.pdf, '_blank');

    // Mostrar pantalla
    document.body.style.overflow = 'hidden';
    detailScreen.classList.add('show');
    floatingBack.style.display = 'block';

    // Rerenderizar MathJax (Necesario cuando el contenido se carga din√°micamente)
    if (window.MathJax) {
        MathJax.typeset([detailEnunciado]);
    }
}

// 3. Oculta la pantalla de detalles
function hideDetail() {
    document.body.style.overflow = 'auto';
    detailScreen.classList.remove('show');
    floatingBack.style.display = 'none';
    
    // Limpiar el contenido de MathJax para evitar errores en el siguiente render
    detailEnunciado.innerHTML = ''; 
}

// 4. Funci√≥n para descargar el c√≥digo de ejemplo
function downloadCode(code, name) {
    const file = new Blob([code], { type: 'text/plain' });
    downloadAnchor.href = URL.createObjectURL(file);
    downloadAnchor.download = `${name.replace(/ /g, '_')}.py`;
    downloadAnchor.click();
}

// 5. Inicializaci√≥n y eventos
document.addEventListener('DOMContentLoaded', () => {
    // Renderizar todas las actividades al cargar
    renderActivities();

    // Eventos de botones
    document.getElementById('closeDetailBtn').addEventListener('click', hideDetail);
    document.getElementById('floatingClose').addEventListener('click', hideDetail);
});

// Nota: Los canvas de fondo se ejecutan autom√°ticamente por sus IIFE.
</script>

</body>
</html>
