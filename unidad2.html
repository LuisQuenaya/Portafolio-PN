<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Unidad 2 ‚Äî Lista de actividades</title>

    <script>
        // Configuraci√≥n expl√≠cita de MathJax (para asegurar el uso de $$...$$)
        MathJax = {
            tex: {
                // Habilita tanto las dobles barras (\( y \)) como los dobles d√≥lares ($$)
                inlineMath: [['$', '$'], ['\\(', '\\)']], 
                displayMath: [['$$', '$$'], ['\\[', '\\]']] 
            },
            svg: {
                fontCache: 'global'
            }
        };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
    </script>
    <style>
        :root{
            --azul-1:#00aaff;
            --azul-2:#004b9a;
            --blanco:#ffffff;
            --negro:#0b0c10;
            --panel: rgba(255,255,255,0.04);
        }
        html,body{
            height:100%;
            margin:0;
            font-family:"Poppins", Arial, sans-serif;
            background:var(--negro);
            color:var(--blanco);
            -webkit-font-smoothing:antialiased;
            overflow:hidden; /* Se cambia a 'auto' al abrir la vista de detalle */
        }
        .bg-canvas{position:fixed;inset:0;z-index:0;pointer-events:none}
        .app{position:relative;z-index:2;min-height:100vh;display:flex;flex-direction:column;align-items:center}
        header{width:100%;text-align:center;padding:48px 20px 10px;box-sizing:border-box;z-index:3}
        header h1{margin:0;font-size:3rem;color:var(--azul-1);text-shadow:0 0 18px rgba(0,170,255,0.12)}
        header h2{margin:6px 0 0;font-weight:400;color:rgba(255,255,255,0.85)}
        .grid-wrap{width:100%;max-width:1100px;padding:28px 20px;box-sizing:border-box;z-index:3;flex:1;display:flex;align-items:flex-start;justify-content:center}
        .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));gap:16px;width:100%}.card{
            background:var(--panel);
            padding:18px;
            border-radius:12px;
            cursor:pointer;
            transition:transform .28s ease, background .28s ease, box-shadow .28s;
            box-shadow: 0 6px 18px rgba(0,0,0,0.45);
            backdrop-filter: blur(4px);
        }
        .card h3{margin:0;color:var(--azul-1);font-size:1.05rem}
        .card p{margin:8px 0 0 0;color:rgba(255,255,255,0.88);font-size:.92rem}
        .card:hover{
            transform: translateY(-8px) scale(1.02);
            background: linear-gradient(180deg, rgba(0,170,255,0.08), rgba(255,255,255,0.02));
            box-shadow: 0 14px 40px rgba(0,170,255,0.12);
        }
        .detail-screen{display:none;position:fixed;inset:0;background:linear-gradient(180deg, rgba(1,6,20,0.95), rgba(0,0,0,0.96));z-index:30;overflow:auto;padding:36px;box-sizing:border-box;opacity:0;transform: translateX(30px);transition: opacity .32s ease, transform .32s ease;}
        .detail-screen.show{ display:block; opacity:1; transform: translateX(0); }
        .detail-inner{max-width:1100px;margin:0 auto;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:18px;box-shadow:0 20px 60px rgba(0,0,0,0.7)}
        .detail-head{display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap}
        .detail-head h2{margin:0;color:var(--azul-1)}
        .controls{display:flex;gap:10px;align-items:center}
        .btn{background:var(--azul-1);color:var(--negro);padding:10px 14px;border-radius:10px;border:none;cursor:pointer;font-weight:700;box-shadow:0 10px 30px rgba(0,170,255,0.12)}
        .btn.secondary{background:#ffffff;color:var(--azul-2)}
        .btn.ghost{background:transparent;color:var(--blanco);border:1px solid rgba(255,255,255,0.06)}
        .content-columns{display:grid;grid-template-columns:1fr 340px;gap:18px;margin-top:14px}
        .enunciado{background:rgba(255,255,255,0.02);padding:14px;border-radius:8px;min-height:160px;color:#e7f7ff;line-height:1.5;}
        .enunciado a {color: var(--azul-1); text-decoration: none;}
        .enunciado a:hover {text-decoration: underline;}
        pre.code{background:#030409;color:#e6fbff;border-left:6px solid var(--azul-2);padding:12px;border-radius:8px;overflow:auto;font-family:Consolas,monospace;white-space: pre-wrap;}
        .meta-card{background:var(--panel);padding:12px;border-radius:8px;margin-bottom:12px}
        .footer-small{text-align:center;color:rgba(255,255,255,0.6);margin-top:26px}
        .volver-floating{position:fixed;right:20px;bottom:18px;z-index:40}
        .volver-floating .btn{padding:10px 12px;border-radius:12px}

        /* ======================
            ESTILO PARA F√ìRMULAS
            ====================== */
        .formula {
            background: rgba(0, 75, 154, 0.2); 
            color: var(--blanco);
            padding: 12px;
            border-left: 5px solid var(--azul-1); 
            margin: 15px 0;
            border-radius: 6px;
            box-shadow: 0 0 10px rgba(0, 170, 255, 0.1);
            overflow-x: auto;
        }

        /* Estilos para tablas en description (Actividad 6) */
        .activity-table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            background: rgba(255,255,255,0.05);
            border-radius: 6px;
        }

        .activity-table th, .activity-table td {
            border: 1px solid rgba(255,255,255,0.1);
            padding: 10px;
            text-align: left;
            font-size: 0.9em;
        }

        .activity-table th {
            background-color: rgba(255,255,255,0.08);
            color: var(--azul-1);
        }
        
        @media (max-width:980px){.content-columns{grid-template-columns:1fr}header h1{font-size:2.2rem}}
    </style>

</head>
<body>

    <canvas id="gradCanvas" class="bg-canvas"></canvas>
    <canvas id="barsCanvas" class="bg-canvas"></canvas>
    <canvas id="netCanvas" class="bg-canvas"></canvas>

    <script>
        // CANVAS 1
        (function(){
            const c = document.getElementById("gradCanvas");
            const ctx = c.getContext("2d");
            function resize(){ c.width = innerWidth; c.height = innerHeight; }
            resize(); addEventListener("resize", resize);
            let t = 0;
            function draw(){
                t += 0.005;
                const g = ctx.createLinearGradient(0, 0, c.width * Math.cos(t), c.height * Math.sin(t));
                g.addColorStop(0, "#00101f");
                g.addColorStop(0.5, "#002b45");
                g.addColorStop(1, "#001a2c");
                ctx.fillStyle = g;
                ctx.fillRect(0,0,c.width,c.height);
                requestAnimationFrame(draw);
            }
            draw();
        })();

        // CANVAS 2
        (function(){
            const c = document.getElementById("barsCanvas");
            const ctx = c.getContext("2d");
            function resize(){ c.width = innerWidth; c.height = innerHeight; }
            resize(); addEventListener("resize", resize);
            const bars = []; const count = 35;
            for(let i=0;i<count;i++){
                bars.push({ x: Math.random()*c.width, h: 80+Math.random()*300, speed:0.4+Math.random()*0.6, alpha:0.08+Math.random()*0.12 });
            }
            function draw(){
                ctx.clearRect(0,0,c.width,c.height);
                bars.forEach(b=>{
                    ctx.fillStyle = `rgba(0,170,255,${b.alpha})`;
                    ctx.fillRect(b.x, 0, 2, b.h);
                    b.h += Math.sin(Date.now()*0.001 + b.x)*0.6;
                });
                requestAnimationFrame(draw);
            }
            draw();
        })();

        // CANVAS 3
        (function(){
            const c = document.getElementById("netCanvas");
            const ctx = c.getContext("2d");
            function resize(){ c.width = innerWidth; c.height = innerHeight; }
            resize(); addEventListener("resize", resize);
            const dots = []; const count = 90;
            for(let i=0;i<count;i++){
                dots.push({ x:Math.random()*c.width, y:Math.random()*c.height,
                    vx:(Math.random()-0.5)*0.6, vy:(Math.random()-0.5)*0.6 });
            }
            function draw(){
                ctx.clearRect(0,0,c.width,c.height);
                dots.forEach(d=>{
                    d.x+=d.vx; d.y+=d.vy;
                    if(d.x<0||d.x>c.width)d.vx*=-1;
                    if(d.y<0||d.y>c.height)d.vy*=-1;
                    ctx.fillStyle="rgba(0,170,255,0.55)";
                    ctx.beginPath(); ctx.arc(d.x,d.y,2,0,Math.PI*2); ctx.fill();
                });
                for(let i=0;i<count;i++){
                    for(let j=i+1;j<count;j++){
                        const dx=dots[i].x-dots[j].x;
                        const dy=dots[i].y-dots[j].y;
                        const dist=Math.sqrt(dx*dx+dy*dy);
                        if(dist<130){
                            ctx.strokeStyle = `rgba(0,170,255,${0.12 - (dist/130)*0.12})`;
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(dots[i].x, dots[i].y);
                            ctx.lineTo(dots[j].x, dots[j].y);
                            ctx.stroke();
                        }
                    }
                }
                requestAnimationFrame(draw);
            }
            draw();
        })();
    </script>

    <div class="app">
        <header>
            <h1>Unidad 2</h1>
            <h2>Lista de actividades</h2>
        </header>

        <div class="grid-wrap">
            <div class="grid" id="activitiesGrid"></div>
        </div>

        <div class="footer-small">¬© 2025 - LUIS ANGEL QUENAYA LOZA</div>
    </div>

    <div class="detail-screen" id="detailScreen" aria-hidden="true">
        <div class="detail-inner">
            <div class="detail-head">
                <h2 id="detailTitle">Actividad</h2>
                <div class="controls">
                    <button class="btn" id="openPdfBtn">üìò Ver PDF</button> 
                    <button class="btn secondary" id="downloadCodeBtn" style="display: none;">üíæ Descargar c√≥digo</button>
                    <button class="btn ghost" id="closeDetailBtn">üîô Volver</button>
                </div>
            </div>

            <div class="content-columns">
                <div>
                    <h3 style="color:var(--azul-1);margin:12px 0 6px 0">üß© Enunciado</h3>
                    <div class="enunciado" id="detailEnunciado"></div> 

                    <div id="codeSection" style="display:none;">
                            <h3 style="color:var(--azul-1);margin:14px 0 6px 0">üíª C√≥digo de ejemplo</h3>
                        <pre class="code"><code id="detailCode"></code></pre>
                    </div>
                </div>

                <aside>
                    <div class="meta-card">
                        <p><strong>Facultad:</strong> FINESI</p>
                        <p><strong>Materia:</strong> Programaci√≥n Num√©rica</p>
                        <p><strong>Fecha entrega:</strong> 21/10/2025</p>
                    </div>
                </aside>
            </div>
        </div>
    </div>

    <div class="volver-floating" id="floatingBack" style="display:none">
        <button class="btn ghost" id="floatingClose">üîô Volver</button>
    </div>

    <a id="downloadAnchor" style="display:none"></a>

<script>
// =========================================================
// ARRAY DE ACTIVIDADES (A1 a A12)
// =========================================================

const activities = [
    { 
        id: 'a1',
        title: 'Actividad 1 ‚Äî M√©todo de Bisecci√≥n',
        pdf: 'BISECCION.pdf',
        description: `
            <p>El m√©todo de bisecci√≥n es un procedimiento iterativo para aproximar las **ra√≠ces** de una funci√≥n continua $f(x)$. Se basa en el **Teorema de Bolzano**, que indica que si $f(a) \\cdot f(b) < 0$ en un intervalo $[a, b]$, existe al menos una ra√≠z dentro del intervalo.</p>

            <p>El m√©todo consiste en dividir el intervalo a la mitad y seleccionar el subintervalo donde la funci√≥n cambia de signo, repitiendo este proceso hasta alcanzar la tolerancia deseada.</p>
            
            <div class="formula">
                **F√≥rmula del punto medio para acotar la ra√≠z:**
                $$ x_m = \frac{a + b}{2} $$
            </div>

            <h4>Importancia de graficar la funci√≥n</h4>
            <p>Antes de iniciar, es **recomendable graficar** $f(x)$ para ubicar aproximadamente el intervalo donde la funci√≥n cambia de signo y elegir valores iniciales $a$ y $b$ adecuados. </p>

            <h4>Ventajas y limitaciones</h4>
            <ul>
                <li>**Ventaja:** Siempre converge si la funci√≥n es continua y $f(a) \\cdot f(b) < 0$.</li>
                <li>**Ventaja:** Simple de implementar.</li>
                <li>**Limitaci√≥n:** Convergencia lineal (**m√°s lenta** que m√©todos como Secante o Newton-Raphson).</li>
                <li>**Limitaci√≥n:** Requiere que la funci√≥n cambie de signo en el intervalo.</li>
            </ul>
            
            <div class="formula">
                **Error absoluto (acotaci√≥n del intervalo):**
                $$ E=\frac{b-a}{2} $$
            </div>
        `,
        code: `
import numpy as np
import matplotlib.pyplot as plt

func_str = input("Ingrese la funci√≥n f(x): ")

def f(x):
    return eval(func_str, {"np": np, "x": x})

a = float(input("Ingrese el valor inicial a: "))
b = float(input("Ingrese el valor inicial b: "))

tol = 1e-6
max_iter = 100

print("\\nIter | a          | b          | xm         | f(xm)      | Error")
print("---------------------------------------------------------------")

for i in range(1, max_iter+1):
    xm = (a + b)/2
    fxm = f(xm)
    error = (b - a)/2
    print(f"{i:4d} | {a:10.6f} | {b:10.6f} | {xm:10.6f} | {fxm:10.6f} | {error:10.6f}")
    
    if abs(fxm) < tol or error < tol:
        raiz = xm
        print(f"\\nRa√≠z aproximada: {raiz:.6f} encontrada en {i} iteraciones")
        break
    
    if f(a)*fxm < 0:
        b = xm
    else:
        a = xm
else:
    print("\\nNo se alcanz√≥ la convergencia despu√©s del m√°ximo de iteraciones")

# C√≥digo de graficaci√≥n
margen = (b - a)*0.1
xmin = a - margen
xmax = b + margen
x = np.linspace(xmin, xmax, 400)
y = f(x)

plt.plot(x, y, label=f"f(x) = {func_str}")
plt.axhline(0, color='black', linestyle='--')
plt.axvline(raiz, color='red', linestyle='--', label=f"Ra√≠z \\u2248 {raiz:.6f}")
plt.title("M√©todo de Bisecci√≥n")
plt.xlabel("x")
plt.ylabel("f(x)")
plt.legend()
plt.grid(True)
plt.show()`
    },
   { 
        id: 'a2',
        title: 'Actividad 2 ‚Äî M√©todo de la Secante',
        pdf: 'Secante.pdf',
        description: `
            <p>El **m√©todo de la secante** es un procedimiento iterativo para aproximar las **ra√≠ces** de una funci√≥n continua $f(x)$. A diferencia de Newton-Raphson, **no necesita derivadas**, ya que la pendiente se estima usando dos puntos cercanos a la ra√≠z.</p>

            <p>Se basa en la idea de reemplazar la tangente por una **secante**, la l√≠nea que une los puntos $(x_{n-1}, f(x_{n-1}))$ y $(x_n, f(x_n))$. La intersecci√≥n de esta secante con el eje $x$ nos da la siguiente aproximaci√≥n:</p>
            
            <div class="formula">
                **F√≥rmula de la Secante:**
                $$ x_{n+1} = x_n - f(x_n) \frac{x_n - x_{n-1}}{f(x_n) - f(x_{n-1})} $$
            </div>
            
            

            <h4>Importancia de graficar la funci√≥n</h4>
            <p>Antes de iniciar, es recomendable **graficar** $f(x)$ para ubicar aproximadamente d√≥nde cruza el eje $x$ y elegir dos valores iniciales $x_0$ y $x_1$ **cercanos a la ra√≠z**, aumentando la probabilidad de convergencia.</p>

            <h4>Ventajas y limitaciones</h4>
            <ul>
                <li>**Ventaja:** No requiere derivadas anal√≠ticas.</li>
                <li>**Ventaja:** Puede ser m√°s r√°pida que el m√©todo de bisecci√≥n.</li>
                <li>**Ventaja:** Convergencia superlineal (m√°s r√°pida que la lineal) si los puntos iniciales son adecuados.</li>
                <li>**Limitaci√≥n:** Puede **divergir** si los puntos iniciales no se eligen bien.</li>
                <li>**Limitaci√≥n:** No garantiza convergencia si la funci√≥n no es continua o si la diferencia $f(x_n) - f(x_{n-1})$ es cercana a cero.</li>
            </ul>
        `,
        code: `
import numpy as np
import matplotlib.pyplot as plt

# === 1. Ingreso de la funci√≥n ===
func_str = input("Ingrese la funci√≥n f(x): ")

# Definir la funci√≥n
def f(x):
    return eval(func_str, {"np": np, "x": x})

# === 2. Graficar la funci√≥n ===
xmin = float(input("Ingrese el valor m√≠nimo de x: "))
xmax = float(input("Ingrese el valor m√°ximo de x: "))

x = np.linspace(xmin, xmax, 400)
y = f(x)

plt.figure(figsize=(8, 5))
plt.plot(x, y, label=f"f(x) = {func_str}", color='blue')
plt.axhline(0, color='black', linestyle='--')
plt.axvline(0, color='black', linestyle='--')
plt.title("Gr√°fico de la funci√≥n ingresada")
plt.xlabel("x")
plt.ylabel("f(x)")
plt.legend()
plt.grid(True)
plt.show()


op = input("¬øS√≠ o No? (s/n): ").lower()

if op == "s":
    # === 4. Ingreso de puntos iniciales ===
    x0 = float(input("Ingrese el primer valor inicial x0: "))
    x1 = float(input("Ingrese el segundo valor inicial x1: "))

    tol = 1e-6
    max_iter = 100

    print("\\nIteraci√≥n |       x0      |       x1      |    f(x0)     |    f(x1)     |       x2      |    Error")
    print("-----------------------------------------------------------------------------------------")

    for i in range(1, max_iter + 1):
        f0 = f(x0)
        f1 = f(x1)

        if f1 - f0 == 0:
            print(f"\\n‚ö†Ô∏è Divisi√≥n por cero en la iteraci√≥n {i}. El m√©todo no puede continuar.")
            break

        # F√≥rmula de la Secante
        x2 = x1 - f1 * (x1 - x0) / (f1 - f0)
        error = abs(x2 - x1)

        print(f"{i:9d} | {x0:11.6f} | {x1:11.6f} | {f0:11.6f} | {f1:11.6f} | {x2:11.6f} | {error:10.6f}")

        if error < tol:
            print(f"\\n‚úÖ Ra√≠z aproximada encontrada: {x2:.6f}")
            print(f"Iteraciones realizadas: {i}")
            break

        x0, x1 = x1, x2

    else:
        print("\\n‚ö†Ô∏è No se alcanz√≥ la convergencia despu√©s de", max_iter, "iteraciones.")
else:
    print("No se aplic√≥ el m√©todo de la Secante.")
`
    },
  { 
        id: 'a3',
        title: 'Actividad 3 ‚Äî M√©todo del Punto Fijo',
        pdf: 'Puntofijo.pdf',
        description: `
            <p>El **M√©todo del Punto Fijo** es un procedimiento iterativo para aproximar las **ra√≠ces** de una ecuaci√≥n $f(x)=0$. Consiste en transformar la ecuaci√≥n original en una forma equivalente $x=g(x)$, donde $g(x)$ es llamada la **funci√≥n de iteraci√≥n**.</p>
            
            <p>El m√©todo genera una sucesi√≥n de aproximaciones mediante la siguiente f√≥rmula, partiendo de un valor inicial $x_0$. Si la sucesi√≥n converge a un valor $r$, entonces $r$ es un **punto fijo** de $g(x)$, y por tanto es la ra√≠z de $f(x)=0$.</p>

            <div class="formula">
                **F√≥rmula de iteraci√≥n:**
                $$ x_{n+1} = g(x_n) $$
            </div>
            
            

            <h4>Condici√≥n de Convergencia (Teorema del Punto Fijo)</h4>
            <p>Para que el m√©todo converja, la funci√≥n $g(x)$ debe cumplir el Teorema del Punto Fijo, donde la condici√≥n m√°s cr√≠tica es:</p>
            <ul>
                <li>$g(x)$ debe ser continua en un intervalo $[a, b]$.</li>
                <li>$g(x) \\in [a, b]$ para todo $x \\in [a, b]$ (El intervalo se mapea en s√≠ mismo).</li>
                <li>**Condici√≥n Clave:** Existe una constante $k < 1$ tal que la derivada cumple:</li>
            </ul>

            <div class="formula">
                **Condici√≥n de convergencia:**
                $$ |g'(x)| \\le k < 1 $$
            </div>

            <p>Si estas condiciones se cumplen, el m√©todo converge a la ra√≠z √∫nica en el intervalo.</p>

            <h4>Ventajas y limitaciones</h4>
            <ul>
                <li>**Ventaja:** M√©todo simple y f√°cil de implementar.</li>
                <li>**Ventaja:** No requiere el c√°lculo de derivadas de la funci√≥n original $f(x)$.</li>
                <li>**Ventaja:** √ötil cuando es f√°cil despejar $x$ de la ecuaci√≥n original.</li>
                <li>**Limitaci√≥n:** La convergencia depende fuertemente de la elecci√≥n de la funci√≥n $g(x)$.</li>
                <li>**Limitaci√≥n:** Puede **divergir** si $|g'(x)| \\ge 1$ cerca de la ra√≠z.</li>
                <li>**Limitaci√≥n:** La velocidad de convergencia es **lineal** (m√°s lenta que m√©todos como Newton-Raphson).</li>
            </ul>
        `,
        code: `
import numpy as np
import matplotlib.pyplot as plt

print("=== M√âTODO DEL PUNTO FIJO ===")

func_str = input("f(x) = ")
g_str = input("g(x) = ")

def f(x):
    return eval(func_str, {"np": np, "x": x})

def g(x):
    return eval(g_str, {"np": np, "x": x})

xmin = float(input("x m√≠n: "))
xmax = float(input("x m√°x: "))

x = np.linspace(xmin, xmax, 400)
y = f(x)

plt.plot(x, y, label=f"f(x)={func_str}", color='blue')
plt.axhline(0, color='black', linestyle='--')
plt.axvline(0, color='black', linestyle='--')
plt.legend()
plt.grid(True)
plt.show(block=False)

x0 = float(input("x0 = "))
tol = 1e-6
max_iter = 100

print("\\nIter |        x_n       |      g(x_n)     |    f(g(x_n))    |     Error")
print("--------------------------------------------------------------------")

for i in range(1, max_iter + 1):
    x1 = g(x0)
    err = abs(x1 - x0)
    fx1 = f(x1)
    print(f"{i:4d} | {x0:14.8f} | {x1:14.8f} | {fx1:14.8f} | {err:10.8f}")
    if err < tol:
        print(f"\\nRa√≠z ‚âà {x1:.8f}")
        break
    x0 = x1
else:
    print("\\nNo se alcanz√≥ la convergencia despu√©s del m√°ximo de iteraciones")
`
    },
    { 
        id: 'a4',
        title: 'Actividad 4 ‚Äî M√©todo de Regula Falsi',
        pdf: 'Regulafalsi.pdf',
        description: `
            <p>El **m√©todo de Regula Falsi** (o **Falsa Posici√≥n**) es un procedimiento iterativo para aproximar **ra√≠ces** de una funci√≥n continua $f(x)$. Al igual que el m√©todo de bisecci√≥n, requiere que $f(a) \\cdot f(b) < 0$ para acotar la ra√≠z.</p>

            <p>En lugar de usar el punto medio, se utiliza la intersecci√≥n con el eje $x$ de la **recta secante** que une los puntos $(a, f(a))$ y $(b, f(b))$. Esto proporciona una mejor aproximaci√≥n en la mayor√≠a de los casos.</p>
            
            <div class="formula">
                **F√≥rmula de Regula Falsi:**
                $$ x_r = b - f(b)\frac{b-a}{f(b)-f(a)} $$
            </div>

            
            
            <h4>Importancia de graficar la funci√≥n</h4>
            <p>Antes de iniciar, es recomendable **graficar** $f(x)$ para ubicar el intervalo donde la funci√≥n cambia de signo y elegir los valores iniciales $a$ y $b$ que acoten la ra√≠z.</p>

            <h4>Ventajas y limitaciones</h4>
            <ul>
                <li>**Ventaja:** Converge m√°s r√°pido que el m√©todo de bisecci√≥n en muchos casos.</li>
                <li>**Ventaja:** Utiliza informaci√≥n de la pendiente aproximada entre los extremos, mejorando la estimaci√≥n.</li>
                <li>**Limitaci√≥n:** Requiere que la funci√≥n cambie de signo en el intervalo.</li>
                <li>**Limitaci√≥n:** Puede experimentar **convergencia lenta** (estancamiento) si la funci√≥n es muy c√≥ncava o convexa cerca de la ra√≠z y uno de los extremos se queda fijo.</li>
            </ul>
        `,
        code: `
import numpy as np
import matplotlib.pyplot as plt

func_str = input("Ingrese la funci√≥n f(x): ")

def f(x):
    return eval(func_str, {"np": np, "x": x})

a = float(input("Ingrese el valor inicial a: "))
b = float(input("Ingrese el valor inicial b: "))

if f(a) * f(b) >= 0:
    print("Error: f(a) y f(b) deben tener signos opuestos.")
else:
    tol = 1e-6
    max_iter = 100
    raiz = None

    print("\\nIter | a          | b          | xr         | f(xr)      | Error")
    print("---------------------------------------------------------------")

    for i in range(1, max_iter+1):
        fa = f(a)
        fb = f(b)
        
        # F√≥rmula de Regula Falsi
        xr = b - fb * (b - a) / (fb - fa)
        fxr = f(xr)
        error = abs(fxr)
        
        print(f"{i:4d} | {a:10.6f} | {b:10.6f} | {xr:10.6f} | {fxr:10.6f} | {error:10.6f}")
        
        if abs(fxr) < tol:
            raiz = xr
            print(f"\\nRa√≠z aproximada: {raiz:.6f} encontrada en {i} iteraciones")
            break
        
        if fa * fxr < 0:
            b = xr
        else:
            a = xr
    else:
        print("\\nNo se alcanz√≥ la convergencia despu√©s del m√°ximo de iteraciones")

    # C√≥digo de graficaci√≥n
    if raiz is not None:
        # Ajuste de margen para la gr√°fica
        margen = 0.1 * (max(b, raiz) - min(a, raiz)) if raiz else 0.1 * (b - a)
        xmin = min(a,b,raiz) - margen
        xmax = max(a,b,raiz) + margen
        x = np.linspace(xmin, xmax, 400)
        y = f(x)

        plt.plot(x, y, label=f"f(x) = {func_str}")
        plt.axhline(0, color='black', linestyle='--')
        plt.axvline(raiz, color='red', linestyle='--', label=f"Ra√≠z \\u2248 {raiz:.6f}")
        plt.title("M√©todo de Regula Falsi")
        plt.xlabel("x")
        plt.ylabel("f(x)")
        plt.legend()
        plt.grid(True)
        plt.show()`
    },
    { 
        id: 'a5',
        title: 'Actividad 5 ‚Äî M√©todo de Newton-Raphson',
        pdf: 'Actividad_05.pdf',
        description: `
            <h4>Descripci√≥n</h4>
            <p>El m√©todo de Newton-Raphson es un procedimiento iterativo que permite obtener una aproximaci√≥n de las ra√≠ces reales de una funci√≥n continua y derivable. Su fundamento se basa en usar la **recta tangente** a la funci√≥n en el punto actual $x_n$ para estimar el siguiente punto $x_{n+1}$.</p>
            <p>Matem√°ticamente, se deriva del desarrollo del polinomio de **Taylor de primer orden** alrededor de un punto inicial $x_0$.</p>

            
            
            <div class="formula">
                **F√≥rmula de Newton-Raphson (Recursiva):**
                $$ x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)} $$
            </div>

            <p>En cada iteraci√≥n se utiliza la pendiente de la tangente $f'(x_n)$ en el punto $x_n$ para aproximarse progresivamente a la ra√≠z. Si la funci√≥n y su derivada son continuas, y el punto inicial est√° cerca de la ra√≠z, la convergencia es **cuadr√°tica** (muy r√°pida).</p>

            <h4>Importancia de la visualizaci√≥n</h4>
            <p>Antes de aplicar el m√©todo, es recomendable **graficar** la funci√≥n $f(x)$ en un intervalo adecuado. Esto permite identificar las zonas donde cruza el eje $x$, estimar una ra√≠z posible y elegir un valor inicial $x_0$ apropiado, lo que incrementa las probabilidades de que el m√©todo converja correctamente.</p>

            <h4>Restricciones y limitaciones</h4>
            <ul>
                <li>**Restricci√≥n Cr√≠tica:** No se debe aplicar cuando la derivada $f'(x_n)$ es cero o muy cercana a cero, ya que genera una indeterminaci√≥n (divisi√≥n por cero).</li>
                <li>Si el punto inicial est√° lejos de la ra√≠z, la **convergencia no est√° garantizada** (puede divergir o converger a otra ra√≠z).</li>
                <li>En ra√≠ces m√∫ltiples, la convergencia puede ser lenta o inestable.</li>
                <li>Se requiere que tanto $f(x)$ como $f'(x)$ sean continuas cerca de la ra√≠z buscada.</li>
            </ul>
        `,
        code: `
import numpy as np
import matplotlib.pyplot as plt
import time

ecuacion = input("Ingrese la funci√≥n f(x): ")

def f(x):
    # Usamos eval de forma controlada para ejecutar la funci√≥n
    return eval(ecuacion, {"np": np, "__builtins__": None, "x": x})

def derivada(x):
    # Aproximaci√≥n num√©rica de la derivada por diferencia central
    h = 1e-6
    return (f(x + h) - f(x - h)) / (2 * h)

a = float(input("Ingrese el l√≠mite inferior del eje x: "))
b = float(input("Ingrese el l√≠mite superior del eje x: "))

x_vals = np.linspace(a, b, 400)
y_vals = f(x_vals)

plt.figure(figsize=(8, 5))
plt.plot(x_vals, y_vals, 'b', label=f"f(x) = {ecuacion}")
plt.axhline(0, color='black', linestyle='--')
plt.axvline(0, color='black', linestyle='--')
plt.title("Gr√°fico de la funci√≥n ingresada")
plt.xlabel("x")
plt.ylabel("f(x)")
plt.legend()
plt.grid(True)
plt.show(block=False)
time.sleep(3)
plt.close()

x = float(input("Ingrese el valor inicial aproximado: "))
tolerancia = 1e-6
iter_max = 100

print("\\nIter | x_n          | f(x_n)      | f'(x_n)     | Error")
print("--------------------------------------------------------------------")

for i in range(iter_max):
    fx = f(x)
    dfx = derivada(x)
    
    if abs(dfx) < 1e-10: # Cuidado con la divisi√≥n por cero
        print(f"La derivada es cero en x = {x:.6f}. No se puede continuar.")
        break
        
    x_nuevo = x - fx / dfx
    error = abs(x_nuevo - x)
    
    print(f"{i+1:4d} | {x:11.6f} | {fx:11.6f} | {dfx:11.6f} | {error:8.6f}")

    if error < tolerancia:
        print(f"\\nRa√≠z encontrada: {x_nuevo:.6f}")
        print(f"N√∫mero de iteraciones: {i + 1}")
        break
        
    x = x_nuevo
else:
    print(f"\\nNo se logr√≥ la convergencia despu√©s de {iter_max} iteraciones.")
    print(f"√öltimo valor aproximado: {x:.6f}")
`
    },
    { 
        id: 'a6',
        title: 'Actividad 6 ‚Äî √çndice H (M√©trica Bibliom√©trica)',
        pdf: 'Actividad6.pdf',
        description: `
            <p>El **√çndice H** (o √≠ndice de Hirsch) mide la productividad y el impacto de un investigador. Un autor tiene un √≠ndice $h$ si $h$ de sus publicaciones tienen al menos $h$ citaciones cada una.</p>
            
            <div class="formula">
                **Definici√≥n Formal:**
                $$ h = \max \\{i \\in \\mathbb{N} : \\text{La publicaci√≥n } i \\text{ tiene al menos } i \\text{ citas} \\} $$
            </div>

            <p>Es una m√©trica clave para evaluar el impacto cient√≠fico.</p>

            <h4>Autores Clave en M√©todos Num√©ricos (Ejemplos de √çndice H)</h4>
            <p>Esta tabla muestra ejemplos de autores importantes en el √°rea (los enlaces son ejemplos de Scopus ID):</p>
            <table class="activity-table">
                <thead>
                    <tr>
                        <th>Autor</th>
                        <th>Investigaci√≥n Central</th>
                        <th>Enlace de Referencia</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Grau, √Ängela</td>
                        <td>M√©todos Secantes para sistemas no lineales</td>
                        <td><a href="https://www.scopus.com/authid/detail.uri?authorId=36545025500" target="_blank">Ver Scopus ID</a></td>
                    </tr>
                    <tr>
                        <td>D√≠az-Barrero, Jos√© Luis</td>
                        <td>Convergencia de m√©todos iterativos</td>
                        <td><a href="https://www.scopus.com/authid/detail.uri?authorId=6602720000" target="_blank">Ver Scopus ID</a></td>
                    </tr>
                    <tr>
                        <td>Argyros, Ioannis K.</td>
                        <td>Algoritmos para problemas no lineales</td>
                        <td><a href="https://www.scopus.com/authid/detail.uri?authorId=7004530784" target="_blank">Ver Scopus ID</a></td>
                    </tr>
                </tbody>
            </table>
        `,
        code: `
# Implementaci√≥n del c√°lculo del √çndice H en Python

def calcular_indice_h(citaciones):
    """
    Calcula el √≠ndice H de un investigador a partir de la lista de citaciones.
    :param citaciones: Una lista de enteros con el n√∫mero de citaciones por publicaci√≥n.
    :return: El valor del √≠ndice H.
    """
    # 1. Ordenar la lista de citaciones de forma descendente
    citaciones_ordenadas = sorted(citaciones, reverse=True)
    n = len(citaciones_ordenadas)
    
    indice_h = 0
    
    # 2. Iterar sobre la lista y encontrar el mayor 'h' tal que la publicaci√≥n 'h' 
    # (en la posici√≥n h-1) tiene al menos 'h' citaciones.
    for i in range(n):
        # i + 1 representa la posici√≥n de la publicaci√≥n (el valor 'h' que buscamos)
        h_candidato = i + 1
        
        # El n√∫mero de citaciones en esta posici√≥n
        citas = citaciones_ordenadas[i]
        
        if citas >= h_candidato:
            indice_h = h_candidato # Se actualiza el √≠ndice H
        else:
            # Si citas < h_candidato, significa que las publicaciones restantes 
            # (con menos citas) no podr√°n cumplir la condici√≥n de h_candidato.
            break
            
    return indice_h

# --- Ejemplo de uso ---
# El primer valor tiene 10 citas, el segundo 8, el tercero 5, el cuarto 4, etc.
citas_ejemplo = [10, 8, 5, 4, 3, 1] 
# Publicaciones ordenadas por citaciones: (10, 8, 5, 4, 3, 1)
# H=1: 10 >= 1 (OK)
# H=2: 8 >= 2 (OK)
# H=3: 5 >= 3 (OK)
# H=4: 4 >= 4 (OK)
# H=5: 3 >= 5 (FALLA) -> El √≠ndice H es 4

print(f"Citaciones del autor: {citas_ejemplo}")
h_index = calcular_indice_h(citas_ejemplo)
print(f"El √çndice H del autor es: {h_index}")

# Otro ejemplo: [15, 12, 10, 8, 5, 3] -> H = 5
citas_ejemplo_2 = [15, 12, 10, 8, 5, 3]
h_index_2 = calcular_indice_h(citas_ejemplo_2)
print(f"\\nCitaciones del autor 2: {citas_ejemplo_2}")
print(f"El √çndice H del autor 2 es: {h_index_2}")
`
    },
    { 
        id: 'a7',
        title: 'Actividad 7 ‚Äî Integraci√≥n Num√©rica (Trapecio)',
        pdf: 'Actividad7.pdf',
        description: `
            <h4>Descripci√≥n</h4>
            <p>El **M√©todo del Trapecio** es un algoritmo de **integraci√≥n num√©rica** que se utiliza para aproximar el valor de una integral definida $\int_a^b f(x) \,dx$. Se basa en reemplazar el √°rea bajo la curva por el √°rea de una serie de **trapecios**.</p>
            <p>La integral se divide en $n$ subintervalos de ancho $h = (b-a)/n$. La aproximaci√≥n es m√°s precisa a medida que se aumenta el n√∫mero de subintervalos $n$.</p>

            <div class="formula">
                **F√≥rmula del Trapecio Simple:**
                $$ \int_a^b f(x) \,dx \approx \frac{b-a}{2}[f(a) + f(b)] $$
            </div>

            <div class="formula">
                **F√≥rmula del Trapecio Compuesto (Regla General):**
                $$ \int_a^b f(x) \,dx \approx \frac{h}{2} [f(x_0) + 2\sum_{i=1}^{n-1} f(x_i) + f(x_n)] $$
            </div>

            
            
            <h4>Error del M√©todo</h4>
            <p>El error de la aproximaci√≥n con el m√©todo del trapecio compuesto se puede acotar por:</p>
            <div class="formula">
                $$ E_T = - \frac{(b-a)^3}{12 n^2} f''(\xi) $$
            </div>
            <p>Donde $\xi$ es un punto en el intervalo $[a, b]$. Esto muestra que el error es inversamente proporcional al cuadrado del n√∫mero de subintervalos ($n^2$), lo que significa que **doblar $n$ reduce el error cuatro veces**.</p>
        `,
        code: `
import numpy as np

print("=== M√âTODO DEL TRAPECIO COMPUESTO ===")

func_str = input("Ingrese la funci√≥n f(x): ")
a = float(input("Ingrese el l√≠mite inferior 'a': "))
b = float(input("Ingrese el l√≠mite superior 'b': "))
n = int(input("Ingrese el n√∫mero de subintervalos 'n': "))

def f(x):
    return eval(func_str, {"np": np, "x": x})

# 1. Calcular el ancho del subintervalo (h)
h = (b - a) / n

# 2. Inicializar la suma con los extremos
# f(x0) + f(xn)
suma = f(a) + f(b)

# 3. Sumar el doble de los t√©rminos intermedios
# 2 * sum(f(xi)) para i = 1 hasta n-1
for i in range(1, n):
    x_i = a + i * h
    suma += 2 * f(x_i)

# 4. Aplicar la f√≥rmula final del trapecio compuesto
integral = (h / 2) * suma

print(f"\\nFunci√≥n: f(x) = {func_str}")
print(f"Intervalo: [{a}, {b}]")
print(f"Subintervalos (n): {n}")
print(f"Ancho (h): {h:.6f}")
print(f"\\nEl valor aproximado de la integral es: {integral:.10f}")
`
    },
    { 
        id: 'a8',
        title: 'Actividad 8 ‚Äî Integraci√≥n Num√©rica (Simpson 1/3)',
        pdf: 'Actividad8.pdf',
        description: `
            <h4>Descripci√≥n</h4>
            <p>La **Regla de Simpson 1/3** es un m√©todo de **integraci√≥n num√©rica** que aproxima la funci√≥n $f(x)$ por un **polinomio de segundo grado** (una par√°bola) en dos subintervalos. Esto proporciona una aproximaci√≥n mucho m√°s precisa que el m√©todo del Trapecio.</p>
            <p>Este m√©todo requiere que el n√∫mero de subintervalos $n$ sea **par**.</p>

            <div class="formula">
                **F√≥rmula de Simpson 1/3 (Simple, para $n=2$):**
                $$ \int_{x_0}^{x_2} f(x) \,dx \approx \frac{h}{3} [f(x_0) + 4f(x_1) + f(x_2)] $$
            </div>

            <div class="formula">
                **F√≥rmula de Simpson 1/3 Compuesto (Regla General, $n$ par):**
                $$ \int_a^b f(x) \,dx \approx \frac{h}{3} \left[f(x_0) + 4\sum_{i \text{ impar}}^{n-1} f(x_i) + 2\sum_{i \text{ par}}^{n-2} f(x_i) + f(x_n)\right] $$
            </div>

            
            
            <h4>Error del M√©todo</h4>
            <p>El error de la aproximaci√≥n con el m√©todo de Simpson 1/3 compuesto se puede acotar por:</p>
            <div class="formula">
                $$ E_S = - \frac{(b-a)^5}{180 n^4} f^{(4)}(\xi) $$
            </div>
            <p>Este error es inversamente proporcional a la cuarta potencia del n√∫mero de subintervalos ($n^4$), lo que indica una **convergencia extremadamente r√°pida** (es de orden 4). **Doblar $n$ reduce el error 16 veces**.</p>
        `,
        code: `
import numpy as np

print("=== REGLA DE SIMPSON 1/3 COMPUESTA ===")

func_str = input("Ingrese la funci√≥n f(x): ")
a = float(input("Ingrese el l√≠mite inferior 'a': "))
b = float(input("Ingrese el l√≠mite superior 'b': "))
n = int(input("Ingrese el n√∫mero de subintervalos 'n' (debe ser par): "))

if n % 2 != 0:
    print("\\n‚ùå Error: El n√∫mero de subintervalos 'n' debe ser un n√∫mero par.")
else:
    def f(x):
        return eval(func_str, {"np": np, "x": x})

    # 1. Calcular el ancho del subintervalo (h)
    h = (b - a) / n

    # 2. Inicializar la suma con los extremos
    # f(x0) + f(xn)
    suma = f(a) + f(b)

    # 3. Sumar t√©rminos intermedios (coeficientes 4 y 2)
    for i in range(1, n):
        x_i = a + i * h
        
        if i % 2 != 0:
            # Coeficiente 4 para √≠ndices impares
            suma += 4 * f(x_i)
        else:
            # Coeficiente 2 para √≠ndices pares
            suma += 2 * f(x_i)

    # 4. Aplicar la f√≥rmula final de Simpson 1/3
    integral = (h / 3) * suma

    print(f"\\nFunci√≥n: f(x) = {func_str}")
    print(f"Intervalo: [{a}, {b}]")
    print(f"Subintervalos (n): {n}")
    print(f"Ancho (h): {h:.6f}")
    print(f"\\nEl valor aproximado de la integral es: {integral:.10f}")
`
    },
    { 
        id: 'a9',
        title: 'Actividad 9 ‚Äî Integraci√≥n Num√©rica (Simpson 3/8)',
        pdf: 'Actividad9.pdf',
        description: `
            <h4>Descripci√≥n</h4>
            <p>La **Regla de Simpson 3/8** es otro m√©todo de **integraci√≥n num√©rica** que mejora la precisi√≥n al aproximar la funci√≥n $f(x)$ por un **polinomio de tercer grado** en tres subintervalos contiguos.</p>
            <p>Este m√©todo requiere que el n√∫mero de subintervalos $n$ sea un **m√∫ltiplo de 3** ($n=3, 6, 9, \dots$).</p>

            <div class="formula">
                **F√≥rmula de Simpson 3/8 (Simple, para $n=3$):**
                $$ \int_{x_0}^{x_3} f(x) \,dx \approx \frac{3h}{8} [f(x_0) + 3f(x_1) + 3f(x_2) + f(x_3)] $$
            </div>

            <div class="formula">
                **F√≥rmula de Simpson 3/8 Compuesto (Regla General, $n$ m√∫ltiplo de 3):**
                $$ \int_a^b f(x) \,dx \approx \frac{3h}{8} \left[f(x_0) + 3\sum_{i \in \\{1, 2, 4, 5, \dots\\}} f(x_i) + 2\sum_{i \in \\{3, 6, 9, \dots\\}} f(x_i) + f(x_n)\right] $$
            </div>

            
            
            <h4>Comparaci√≥n con Simpson 1/3</h4>
            <ul>
                <li>Ambos m√©todos tienen una precisi√≥n de orden cuatro ($O(h^4)$), pero Simpson 1/3 suele ser ligeramente m√°s utilizado por su simplicidad y el menor factor de error constante.</li>
                <li>Simpson 3/8 es √∫til cuando el n√∫mero de subintervalos disponibles naturalmente es un m√∫ltiplo de 3, o para ser combinado con Simpson 1/3 cuando $n$ no es par ni m√∫ltiplo de 3 (M√©todo Compuesto Mixto).</li>
                <li>El error es inversamente proporcional a $n^4$, al igual que Simpson 1/3, garantizando una convergencia r√°pida.</li>
            </ul>
        `,
        code: `
import numpy as np

print("=== REGLA DE SIMPSON 3/8 COMPUESTA ===")

func_str = input("Ingrese la funci√≥n f(x): ")
a = float(input("Ingrese el l√≠mite inferior 'a': "))
b = float(input("Ingrese el l√≠mite superior 'b': "))
n = int(input("Ingrese el n√∫mero de subintervalos 'n' (debe ser m√∫ltiplo de 3): "))

if n % 3 != 0:
    print("\\n‚ùå Error: El n√∫mero de subintervalos 'n' debe ser m√∫ltiplo de 3.")
else:
    def f(x):
        return eval(func_str, {"np": np, "x": x})

    # 1. Calcular el ancho del subintervalo (h)
    h = (b - a) / n

    # 2. Inicializar la suma con los extremos
    # f(x0) + f(xn)
    suma = f(a) + f(b)

    # 3. Sumar t√©rminos intermedios (coeficientes 3 y 2)
    for i in range(1, n):
        x_i = a + i * h
        
        if i % 3 == 0:
            # Coeficiente 2 para los m√∫ltiplos de 3 (que no son los extremos)
            suma += 2 * f(x_i)
        else:
            # Coeficiente 3 para los dem√°s
            suma += 3 * f(x_i)

    # 4. Aplicar la f√≥rmula final de Simpson 3/8
    integral = (3 * h / 8) * suma

    print(f"\\nFunci√≥n: f(x) = {func_str}")
    print(f"Intervalo: [{a}, {b}]")
    print(f"Subintervalos (n): {n}")
    print(f"Ancho (h): {h:.6f}")
    print(f"\\nEl valor aproximado de la integral es: {integral:.10f}")
`
    },
    { 
        id: 'a10',
        title: 'Actividad 10 ‚Äî Sistemas de Ecuaciones (Jacobi)',
        pdf: 'Actividad10.pdf',
        description: `
            <h4>Descripci√≥n</h4>
            <p>El **M√©todo de Jacobi** es un algoritmo iterativo utilizado para resolver **sistemas de ecuaciones lineales** de la forma $\mathbf{A}\mathbf{x} = \mathbf{b}$. Es especialmente √∫til para sistemas grandes y dispersos.</p>
            <p>El m√©todo se basa en descomponer la matriz $\mathbf{A}$ en tres componentes: $\mathbf{A} = \mathbf{D} + \mathbf{L} + \mathbf{U}$, donde $\mathbf{D}$ es la diagonal, $\mathbf{L}$ es la triangular inferior estricta y $\mathbf{U}$ es la triangular superior estricta. A partir de esto, se obtiene una f√≥rmula iterativa.</p>

            <div class="formula">
                **F√≥rmula de iteraci√≥n de Jacobi:**
                $$ x_i^{(k+1)} = \frac{1}{a_{ii}} \left(b_i - \sum_{j \neq i} a_{ij} x_j^{(k)}\right) $$
            </div>

            <p>Donde $x_i^{(k+1)}$ es el nuevo valor de la variable $i$ en la iteraci√≥n $k+1$, y $x_j^{(k)}$ son los valores de la iteraci√≥n anterior $k$.</p>

            
            
            <h4>Condici√≥n de Convergencia</h4>
            <p>La convergencia del m√©todo de Jacobi est√° garantizada si la matriz de coeficientes $\mathbf{A}$ es **diagonalmente dominante**. Esto significa que el valor absoluto de cada elemento en la diagonal principal es mayor que la suma de los valores absolutos de los dem√°s elementos en esa misma fila.</p>
            <div class="formula">
                **Criterio de Dominancia Diagonal:**
                $$ |a_{ii}| > \sum_{j=1, j\neq i}^{n} |a_{ij}| \quad \text{para todo } i=1, \dots, n $$
            </div>
            <p>Si esta condici√≥n se cumple, el m√©todo converge a la soluci√≥n, independientemente del vector inicial $\mathbf{x}^{(0)}$.</p>
        `,
        code: `
import numpy as np

print("=== M√âTODO ITERATIVO DE JACOBI ===")

# --- 1. Definici√≥n del sistema ---
# Ejemplo de matriz de coeficientes (A) - Diagonalmente Dominante
A = np.array([
    [10, 2, 1],
    [1, 5, 1],
    [2, 3, 10]
], dtype=float)

# Ejemplo de vector de t√©rminos independientes (b)
b = np.array([7, -8, 6], dtype=float)

# N√∫mero de ecuaciones/variables
n = len(b)

# --- 2. Par√°metros de la iteraci√≥n ---
x = np.zeros(n) # Vector inicial de soluciones (x^0)
tol = 1e-4      # Tolerancia
max_iter = 50   # M√°ximo de iteraciones

# --- 3. Ejecuci√≥n del m√©todo de Jacobi ---
print(f"\\nSistema Ax = b:\\nA = \\n{A}\\nb = {b}")
print("\\nIter | x1        | x2        | x3        | Error Max.")
print("-------------------------------------------------------")

for k in range(max_iter):
    x_prev = x.copy()
    error_max = 0.0
    
    for i in range(n):
        suma = 0.0
        for j in range(n):
            if i != j:
                suma += A[i, j] * x_prev[j]
        
        # F√≥rmula de iteraci√≥n de Jacobi
        if A[i, i] == 0:
            print("\\n‚ùå Error: La diagonal contiene un cero. La matriz no es invertible por este m√©todo.")
            exit()
            
        x[i] = (b[i] - suma) / A[i, i]
        
        # C√°lculo del error (diferencia m√°xima entre iteraciones)
        error = abs(x[i] - x_prev[i])
        if error > error_max:
            error_max = error
            
    # Mostrar resultados de la iteraci√≥n
    print(f"{k+1:4d} | {x[0]:9.6f} | {x[1]:9.6f} | {x[2]:9.6f} | {error_max:10.8f}")
    
    # Condici√≥n de parada
    if error_max < tol:
        print(f"\\n‚úÖ Soluci√≥n encontrada en {k+1} iteraciones.")
        print(f"Soluci√≥n: x = {x}")
        break
else:
    print(f"\\n‚ö†Ô∏è El m√©todo no convergi√≥ despu√©s de {max_iter} iteraciones.")
    print(f"√öltima aproximaci√≥n: x = {x}")

# Soluci√≥n con NumPy para verificar (opcional)
# x_numpy = np.linalg.solve(A, b)
# print(f"\\nSoluci√≥n exacta (NumPy): {x_numpy}")
`
    },
    { 
        id: 'a11',
        title: 'Actividad 11 ‚Äî Sistemas de Ecuaciones (Gauss-Seidel)',
        pdf: 'Actividad11.pdf',
        description: `
            <h4>Descripci√≥n</h4>
            <p>El **M√©todo de Gauss-Seidel** es una mejora del M√©todo de Jacobi para resolver sistemas de ecuaciones lineales $\mathbf{A}\mathbf{x} = \mathbf{b}$. Su principal diferencia es que utiliza inmediatamente los **valores de las variables reci√©n calculadas** en la misma iteraci√≥n para las siguientes ecuaciones.</p>
            <p>Esto generalmente resulta en una **convergencia m√°s r√°pida** que el m√©todo de Jacobi.</p>

            <div class="formula">
                **F√≥rmula de iteraci√≥n de Gauss-Seidel:**
                $$ x_i^{(k+1)} = \frac{1}{a_{ii}} \left(b_i - \sum_{j=1}^{i-1} a_{ij} x_j^{(k+1)} - \sum_{j=i+1}^{n} a_{ij} x_j^{(k)}\right) $$
            </div>

            <p>Note que para la primera sumatoria se usan los valores de la **iteraci√≥n actual** ($k+1$) y para la segunda, los valores de la **iteraci√≥n anterior** ($k$).</p>

            
            
            <h4>Condici√≥n de Convergencia</h4>
            <p>Al igual que Jacobi, la convergencia est√° garantizada si la matriz $\mathbf{A}$ es **diagonalmente dominante**. Sin embargo, Gauss-Seidel puede converger incluso en casos donde Jacobi diverge, o viceversa.</p>
            <ul>
                <li>**Criterio Suficiente:** Si $\mathbf{A}$ es diagonalmente dominante, Gauss-Seidel converge.</li>
                <li>**Criterio de Sassenfeld:** Un criterio m√°s general que no requiere la dominancia diagonal, pero es m√°s complejo de calcular.</li>
            </ul>
            <p>Debido a la actualizaci√≥n inmediata, es el m√©todo iterativo m√°s com√∫n en aplicaciones de ingenier√≠a.</p>
        `,
        code: `
import numpy as np

print("=== M√âTODO ITERATIVO DE GAUSS-SEIDEL ===")

# --- 1. Definici√≥n del sistema ---
# Ejemplo de matriz de coeficientes (A) - Diagonalmente Dominante
A = np.array([
    [10, 2, 1],
    [1, 5, 1],
    [2, 3, 10]
], dtype=float)

# Ejemplo de vector de t√©rminos independientes (b)
b = np.array([7, -8, 6], dtype=float)

# N√∫mero de ecuaciones/variables
n = len(b)

# --- 2. Par√°metros de la iteraci√≥n ---
x = np.zeros(n) # Vector inicial de soluciones (x^0)
tol = 1e-4      # Tolerancia
max_iter = 50   # M√°ximo de iteraciones

# --- 3. Ejecuci√≥n del m√©todo de Gauss-Seidel ---
print(f"\\nSistema Ax = b:\\nA = \\n{A}\\nb = {b}")
print("\\nIter | x1        | x2        | x3        | Error Max.")
print("-------------------------------------------------------")

for k in range(max_iter):
    x_prev = x.copy()
    error_max = 0.0
    
    for i in range(n):
        # 1. Suma de t√©rminos ya calculados (j < i) - usa x[j] de la iteraci√≥n actual (k+1)
        sum_k_plus_1 = 0.0
        for j in range(i):
            sum_k_plus_1 += A[i, j] * x[j] # ¬°Usa el valor actualizado de x[j]!

        # 2. Suma de t√©rminos pendientes (j > i) - usa x_prev[j] de la iteraci√≥n anterior (k)
        sum_k = 0.0
        for j in range(i + 1, n):
            sum_k += A[i, j] * x_prev[j] # ¬°Usa el valor anterior de x[j]!

        # F√≥rmula de iteraci√≥n de Gauss-Seidel
        if A[i, i] == 0:
            print("\\n‚ùå Error: La diagonal contiene un cero. La matriz no es invertible por este m√©todo.")
            exit()
            
        x[i] = (b[i] - sum_k_plus_1 - sum_k) / A[i, i]
        
        # C√°lculo del error (diferencia m√°xima entre el valor actual y el anterior)
        error = abs(x[i] - x_prev[i])
        if error > error_max:
            error_max = error
            
    # Mostrar resultados de la iteraci√≥n
    print(f"{k+1:4d} | {x[0]:9.6f} | {x[1]:9.6f} | {x[2]:9.6f} | {error_max:10.8f}")
    
    # Condici√≥n de parada
    if error_max < tol:
        print(f"\\n‚úÖ Soluci√≥n encontrada en {k+1} iteraciones.")
        print(f"Soluci√≥n: x = {x}")
        break
else:
    print(f"\\n‚ö†Ô∏è El m√©todo no convergi√≥ despu√©s de {max_iter} iteraciones.")
    print(f"√öltima aproximaci√≥n: x = {x}")
`
    },
    { 
        id: 'a12',
        title: 'Actividad 12 ‚Äî Interpolaci√≥n (Lagrange)',
        pdf: 'Actividad12.pdf',
        description: `
            <h4>Descripci√≥n</h4>
            <p>La **Interpolaci√≥n de Lagrange** es un m√©todo para construir un **polinomio** que pasa exactamente por un conjunto dado de $n+1$ puntos $(x_i, y_i)$. El polinomio resultante, $P_n(x)$, tiene un grado menor o igual a $n$ y se denomina **Polinomio de Lagrange**.</p>
            <p>A diferencia de otros m√©todos (como Newton), no requiere el c√°lculo de diferencias divididas, sino que construye el polinomio como una suma de polinomios base $L_i(x)$.</p>

            <div class="formula">
                **Polinomio de Interpolaci√≥n de Lagrange:**
                $$ P_n(x) = \sum_{i=0}^{n} y_i L_i(x) $$
            </div>

            <p>Donde $L_i(x)$ son los **polinomios base de Lagrange** definidos como:</p>
            <div class="formula">
                **Polinomios Base de Lagrange:**
                $$ L_i(x) = \prod_{j=0, j \neq i}^{n} \frac{x - x_j}{x_i - x_j} $$
            </div>
            
            

            <h4>Ventajas y Desventajas</h4>
            <ul>
                <li>**Ventaja:** Es muy simple conceptualmente y f√°cil de implementar directamente a partir de los puntos.</li>
                <li>**Ventaja:** Garantiza que el polinomio pasa por todos los puntos de datos.</li>
                <li>**Desventaja:** Requiere recalcular todo el polinomio si se a√±ade un nuevo punto de datos (a diferencia de la forma de Newton con diferencias divididas).</li>
                <li>**Desventaja:** El fen√≥meno de **Runge** (grandes oscilaciones en los bordes) puede ocurrir con muchos puntos espaciados uniformemente.</li>
            </ul>
        `,
        code: `
import numpy as np
import matplotlib.pyplot as plt

print("=== M√âTODO DE INTERPOLACI√ìN DE LAGRANGE ===")

# --- 1. Entrada de datos ---
print("Ingrese los puntos (x, y) de la funci√≥n. Det√©ngase con una l√≠nea vac√≠a.")
puntos = []
while True:
    try:
        entrada = input("Punto (x, y): ")
        if not entrada:
            break
        x, y = map(float, entrada.split(','))
        puntos.append((x, y))
    except ValueError:
        print("Entrada inv√°lida. Use el formato 'x,y'.")

if len(puntos) < 2:
    print("Se necesitan al menos dos puntos para la interpolaci√≥n.")
    exit()

# Separar x e y
x_data = np.array([p[0] for p in puntos])
y_data = np.array([p[1] for p in puntos])
n = len(x_data) - 1 # Grado del polinomio

# --- 2. Funci√≥n del polinomio base de Lagrange L_i(x) ---
def L_i(x, i, x_data):
    """Calcula el i-√©simo polinomio base de Lagrange."""
    resultado = 1.0
    for j in range(len(x_data)):
        if i != j:
            # Producto: (x - x_j) / (x_i - x_j)
            resultado *= (x - x_data[j]) / (x_data[i] - x_data[j])
    return resultado

# --- 3. Funci√≥n del Polinomio de Lagrange P_n(x) ---
def P_n(x, x_data, y_data):
    """Calcula el Polinomio de Lagrange P_n(x)."""
    Pn_x = 0.0
    for i in range(len(x_data)):
        # Sumatoria: y_i * L_i(x)
        Pn_x += y_data[i] * L_i(x, i, x_data)
    return Pn_x

# --- 4. Interpolaci√≥n y Visualizaci√≥n ---

# Valor a interpolar
x_interpolar = float(input("\\nIngrese el valor de 'x' para interpolar: "))
y_interpolar = P_n(x_interpolar, x_data, y_data)

print(f"\\nValor interpolado P{n}({x_interpolar:.4f}) = {y_interpolar:.8f}")

# Gr√°fico
x_plot = np.linspace(np.min(x_data) - 0.5, np.max(x_data) + 0.5, 200)
y_plot = P_n(x_plot, x_data, y_data)

plt.figure(figsize=(9, 6))
# Polinomio interpolador
plt.plot(x_plot, y_plot, 'b-', label=f'P{n}(x) de Lagrange') 
# Puntos de datos
plt.plot(x_data, y_data, 'ro', label='Puntos de datos')
# Punto interpolado
plt.plot(x_interpolar, y_interpolar, 'go', markersize=8, label=f'Punto interpolado ({x_interpolar:.2f}, {y_interpolar:.2f})')

plt.title("Interpolaci√≥n Polinomial de Lagrange")
plt.xlabel("x")
plt.ylabel("P(x)")
plt.legend()
plt.grid(True)
plt.show()
`
    }
];

// =========================================================
// L√ìGICA DE LA INTERFAZ
// =========================================================

const activitiesGrid = document.getElementById('activitiesGrid');
const detailScreen = document.getElementById('detailScreen');
const detailTitle = document.getElementById('detailTitle');
const detailEnunciado = document.getElementById('detailEnunciado');
const detailCode = document.getElementById('detailCode');
const codeSection = document.getElementById('codeSection');
const closeDetailBtn = document.getElementById('closeDetailBtn');
const floatingClose = document.getElementById('floatingClose');
const floatingBack = document.getElementById('floatingBack');
const downloadCodeBtn = document.getElementById('downloadCodeBtn');
const downloadAnchor = document.getElementById('downloadAnchor');
const openPdfBtn = document.getElementById('openPdfBtn');

let currentActivity = null;

// Funci√≥n para renderizar las tarjetas en la cuadr√≠cula
function renderGrid() {
    activitiesGrid.innerHTML = '';
    activities.forEach(activity => {
        const card = document.createElement('div');
        card.classList.add('card');
        card.setAttribute('data-id', activity.id);
        
        card.innerHTML = `
            <h3>${activity.title.split('‚Äî')[0].trim()}</h3>
            <p>${activity.title.split('‚Äî')[1].trim()}</p>
        `;
        
        card.addEventListener('click', () => showDetail(activity));
        activitiesGrid.appendChild(card);
    });
}

// Funci√≥n para mostrar la vista de detalle
function showDetail(activity) {
    currentActivity = activity;
    
    // 1. Rellenar contenido
    detailTitle.textContent = activity.title;
    detailEnunciado.innerHTML = activity.description;
    
    // Configurar secci√≥n de c√≥digo (si existe)
    if (activity.code) {
        detailCode.textContent = activity.code.trim();
        codeSection.style.display = 'block';
        downloadCodeBtn.style.display = 'inline-block';
    } else {
        detailCode.textContent = '';
        codeSection.style.display = 'none';
        downloadCodeBtn.style.display = 'none';
    }
    
    // 2. Mostrar/Ocultar elementos de la interfaz
    detailScreen.classList.add('show');
    document.body.style.overflow = 'auto'; // Habilitar scroll en detalle
    
    // 3. Renderizar f√≥rmulas con MathJax (si las hay)
    if (window.MathJax) {
        MathJax.typesetPromise([detailEnunciado]).then(() => {
            // Callback despu√©s de que MathJax termine de renderizar
        });
    }

    // 4. Actualizar botones de acci√≥n
    openPdfBtn.onclick = () => {
        alert(`Simulando apertura de PDF: ${activity.pdf}`);
        // window.open(activity.pdf, '_blank'); // Descomentar para abrir PDF real
    };

    downloadCodeBtn.onclick = () => downloadCode(activity);
}

// Funci√≥n para cerrar la vista de detalle
function closeDetail() {
    detailScreen.classList.remove('show');
    document.body.style.overflow = 'hidden'; // Restaurar overflow
    currentActivity = null;
    
    // Forzar re-renderizado de MathJax en caso de que la grilla lo necesite (aunque no lo hace aqu√≠)
    if (window.MathJax) {
        MathJax.typesetPromise([activitiesGrid]);
    }
}

// Funci√≥n para descargar el c√≥digo
function downloadCode(activity) {
    if (!activity.code) return;

    const filename = `${activity.id}_${activity.title.split('‚Äî')[0].trim().replace(/\s/g, '_')}.py`;
    const codeContent = activity.code.trim();
    const file = new Blob([codeContent], {type: 'text/plain'});
    
    downloadAnchor.href = URL.createObjectURL(file);
    downloadAnchor.download = filename;
    downloadAnchor.click();

    URL.revokeObjectURL(downloadAnchor.href); // Liberar memoria
    alert(`Descargando ${filename}...`);
}

// Event Listeners
closeDetailBtn.addEventListener('click', closeDetail);
floatingClose.addEventListener('click', closeDetail); // El bot√≥n flotante (no se usa)

// Ejecutar la renderizaci√≥n inicial
document.addEventListener('DOMContentLoaded', renderGrid);
</script>

</body>
</html>
