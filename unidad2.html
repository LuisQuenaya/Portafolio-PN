<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Unidad 2 ‚Äî Lista de actividades</title>

    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
    </script>

    <style>
        :root{
            --azul-1:#00aaff;
            --azul-2:#004b9a;
            --blanco:#ffffff;
            --negro:#0b0c10;
            --panel: rgba(255,255,255,0.04);
        }
        html,body{
            height:100%;
            margin:0;
            font-family:"Poppins", Arial, sans-serif;
            background:var(--negro);
            color:var(--blanco);
            -webkit-font-smoothing:antialiased;
            overflow:hidden;
        }
        .bg-canvas{position:fixed;inset:0;z-index:0;pointer-events:none}
        .app{position:relative;z-index:2;min-height:100vh;display:flex;flex-direction:column;align-items:center}
        header{width:100%;text-align:center;padding:48px 20px 10px;box-sizing:border-box;z-index:3}
        header h1{margin:0;font-size:3rem;color:var(--azul-1);text-shadow:0 0 18px rgba(0,170,255,0.12)}
        header h2{margin:6px 0 0;font-weight:400;color:rgba(255,255,255,0.85)}
        .grid-wrap{width:100%;max-width:1100px;padding:28px 20px;box-sizing:border-box;z-index:3;flex:1;display:flex;align-items:flex-start;justify-content:center}
        .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));gap:16px;width:100%}
        .card{
            background:var(--panel);
            padding:18px;
            border-radius:12px;
            cursor:pointer;
            transition:transform .28s ease, background .28s ease, box-shadow .28s;
            box-shadow: 0 6px 18px rgba(0,0,0,0.45);
            backdrop-filter: blur(4px);
        }
        .card h3{margin:0;color:var(--azul-1);font-size:1.05rem}
        .card p{margin:8px 0 0 0;color:rgba(255,255,255,0.88);font-size:.92rem}
        .card:hover{
            transform: translateY(-8px) scale(1.02);
            background: linear-gradient(180deg, rgba(0,170,255,0.08), rgba(255,255,255,0.02));
            box-shadow: 0 14px 40px rgba(0,170,255,0.12);
        }
        .detail-screen{display:none;position:fixed;inset:0;background:linear-gradient(180deg, rgba(1,6,20,0.95), rgba(0,0,0,0.96));z-index:30;overflow:auto;padding:36px;box-sizing:border-box;opacity:0;transform: translateX(30px);transition: opacity .32s ease, transform .32s ease;}
        .detail-screen.show{ display:block; opacity:1; transform: translateX(0); }
        .detail-inner{max-width:1100px;margin:0 auto;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:18px;box-shadow:0 20px 60px rgba(0,0,0,0.7)}
        .detail-head{display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap}
        .detail-head h2{margin:0;color:var(--azul-1)}
        .controls{display:flex;gap:10px;align-items:center}
        .btn{background:var(--azul-1);color:var(--negro);padding:10px 14px;border-radius:10px;border:none;cursor:pointer;font-weight:700;box-shadow:0 10px 30px rgba(0,170,255,0.12)}
        .btn.secondary{background:#ffffff;color:var(--azul-2)}
        .btn.ghost{background:transparent;color:var(--blanco);border:1px solid rgba(255,255,255,0.06)}
        .content-columns{display:grid;grid-template-columns:1fr 340px;gap:18px;margin-top:14px}
        .enunciado{background:rgba(255,255,255,0.02);padding:14px;border-radius:8px;min-height:160px;color:#e7f7ff;line-height:1.5;}
        .enunciado a {color: var(--azul-1); text-decoration: none;}
        .enunciado a:hover {text-decoration: underline;}
        pre.code{background:#030409;color:#e6fbff;border-left:6px solid var(--azul-2);padding:12px;border-radius:8px;overflow:auto;font-family:Consolas,monospace;white-space: pre-wrap; /* Para asegurar que el c√≥digo se descargue tal cual */}
        .meta-card{background:var(--panel);padding:12px;border-radius:8px;margin-bottom:12px}
        .footer-small{text-align:center;color:rgba(255,255,255,0.6);margin-top:26px}
        .volver-floating{position:fixed;right:20px;bottom:18px;z-index:40}
        .volver-floating .btn{padding:10px 12px;border-radius:12px}

        /* ======================
            ESTILO PARA F√ìRMULAS (Mejorado para el tema oscuro)
            ====================== */
        .formula {
            background: rgba(0, 75, 154, 0.2); /* Fondo azul oscuro claro */
            color: var(--blanco);
            padding: 12px;
            border-left: 5px solid var(--azul-1); /* Borde azul brillante */
            margin: 15px 0;
            border-radius: 6px;
            box-shadow: 0 0 10px rgba(0, 170, 255, 0.1);
            overflow-x: auto;
        }

        /* Estilos para tablas en description (Actividad 6) */
        .activity-table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            background: rgba(255,255,255,0.05);
            border-radius: 6px;
        }

        .activity-table th, .activity-table td {
            border: 1px solid rgba(255,255,255,0.1);
            padding: 10px;
            text-align: left;
            font-size: 0.9em;
        }

        .activity-table th {
            background-color: rgba(255,255,255,0.08);
            color: var(--azul-1);
        }
        
        @media (max-width:980px){.content-columns{grid-template-columns:1fr}header h1{font-size:2.2rem}}
    </style>

</head>
<body>

    <canvas id="gradCanvas" class="bg-canvas"></canvas>
    <canvas id="barsCanvas" class="bg-canvas"></canvas>
    <canvas id="netCanvas" class="bg-canvas"></canvas>

    <script>
        // CANVAS 1
        (function(){
            const c = document.getElementById("gradCanvas");
            const ctx = c.getContext("2d");
            function resize(){ c.width = innerWidth; c.height = innerHeight; }
            resize(); addEventListener("resize", resize);
            let t = 0;
            function draw(){
                t += 0.005;
                const g = ctx.createLinearGradient(0, 0, c.width * Math.cos(t), c.height * Math.sin(t));
                g.addColorStop(0, "#00101f");
                g.addColorStop(0.5, "#002b45");
                g.addColorStop(1, "#001a2c");
                ctx.fillStyle = g;
                ctx.fillRect(0,0,c.width,c.height);
                requestAnimationFrame(draw);
            }
            draw();
        })();

        // CANVAS 2
        (function(){
            const c = document.getElementById("barsCanvas");
            const ctx = c.getContext("2d");
            function resize(){ c.width = innerWidth; c.height = innerHeight; }
            resize(); addEventListener("resize", resize);
            const bars = []; const count = 35;
            for(let i=0;i<count;i++){
                bars.push({ x: Math.random()*c.width, h: 80+Math.random()*300, speed:0.4+Math.random()*0.6, alpha:0.08+Math.random()*0.12 });
            }
            function draw(){
                ctx.clearRect(0,0,c.width,c.height);
                bars.forEach(b=>{
                    ctx.fillStyle = `rgba(0,170,255,${b.alpha})`;
                    ctx.fillRect(b.x, 0, 2, b.h);
                    b.h += Math.sin(Date.now()*0.001 + b.x)*0.6;
                });
                requestAnimationFrame(draw);
            }
            draw();
        })();

        // CANVAS 3
        (function(){
            const c = document.getElementById("netCanvas");
            const ctx = c.getContext("2d");
            function resize(){ c.width = innerWidth; c.height = innerHeight; }
            resize(); addEventListener("resize", resize);
            const dots = []; const count = 90;
            for(let i=0;i<count;i++){
                dots.push({ x:Math.random()*c.width, y:Math.random()*c.height,
                    vx:(Math.random()-0.5)*0.6, vy:(Math.random()-0.5)*0.6 });
            }
            function draw(){
                ctx.clearRect(0,0,c.width,c.height);
                dots.forEach(d=>{
                    d.x+=d.vx; d.y+=d.vy;
                    if(d.x<0||d.x>c.width)d.vx*=-1;
                    if(d.y<0||d.y>c.height)d.vy*=-1;
                    ctx.fillStyle="rgba(0,170,255,0.55)";
                    ctx.beginPath(); ctx.arc(d.x,d.y,2,0,Math.PI*2); ctx.fill();
                });
                for(let i=0;i<count;i++){
                    for(let j=i+1;j<count;j++){
                        const dx=dots[i].x-dots[j].x;
                        const dy=dots[i].y-dots[j].y;
                        const dist=Math.sqrt(dx*dx+dy*dy);
                        if(dist<130){
                            ctx.strokeStyle = `rgba(0,170,255,${0.12 - (dist/130)*0.12})`;
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(dots[i].x, dots[i].y);
                            ctx.lineTo(dots[j].x, dots[j].y);
                            ctx.stroke();
                        }
                    }
                }
                requestAnimationFrame(draw);
            }
            draw();
        })();
    </script>

    <div class="app">
        <header>
            <h1>Unidad 2</h1>
            <h2>Lista de actividades</h2>
        </header>

        <div class="grid-wrap">
            <div class="grid" id="activitiesGrid"></div>
        </div>

        <div class="footer-small">¬© 2025 - LUIS ANGEL QUENAYA LOZA</div>
    </div>

    <div class="detail-screen" id="detailScreen" aria-hidden="true">
        <div class="detail-inner">
            <div class="detail-head">
                <h2 id="detailTitle">Actividad</h2>
                <div class="controls">
                    <button class="btn" id="openPdfBtn">üìò Ver PDF</button> 
                    <button class="btn secondary" id="downloadCodeBtn">üíæ Descargar c√≥digo</button>
                    <button class="btn ghost" id="closeDetailBtn">üîô Volver</button>
                </div>
            </div>

            <div class="content-columns">
                <div>
                    <h3 style="color:var(--azul-1);margin:12px 0 6px 0">üß© Enunciado</h3>
                    <div class="enunciado" id="detailEnunciado"></div> 

                    <h3 style="color:var(--azul-1);margin:14px 0 6px 0">üíª C√≥digo de ejemplo</h3>
                    <pre class="code"><code id="detailCode"></code></pre>
                </div>

                <aside>
                    <div class="meta-card">
                        <p><strong>Facultad:</strong> FINESI</p>
                        <p><strong>Materia:</strong> Programaci√≥n Num√©rica</p>
                        <p><strong>Fecha entrega:</strong> 21/10/2025</p>
                    </div>
                </aside>
            </div>
        </div>
    </div>

    <div class="volver-floating" id="floatingBack" style="display:none">
        <button class="btn ghost" id="floatingClose">üîô Volver</button>
    </div>

    <a id="downloadAnchor" style="display:none"></a>

<script>
// Array de Actividades (DATOS ORIGINALES, SOLO description y code MODIFICADOS para 6-12)
const activities = [
    {
        id: 'a1',
        title: 'Actividad 1 ‚Äî M√©todo de Bisecci√≥n',
        pdf: 'BISECCION.pdf',
        description: `
            <p>El m√©todo de bisecci√≥n es un procedimiento num√©rico que permite encontrar una ra√≠z de una funci√≥n continua dentro de un intervalo $[a, b]$. Se basa en el **teorema de Bolzano**, que indica que si $f(a)$ y $f(b)$ tienen signos opuestos, entonces existe al menos una ra√≠z dentro del intervalo.</p>

            <div class="formula">
                $$ x_m = \frac{a + b}{2} $$
            </div>

            <p>El intervalo se reduce a la mitad en cada iteraci√≥n, garantizando la convergencia.</p>
            
            <div class="formula">
                **Condici√≥n de reemplazo:** Si $f(a) \cdot f(x_m) < 0$, la ra√≠z est√° en $[a, x_m]$; de lo contrario, est√° en $[x_m, b]$.
            </div>

            <div class="formula">
                **Error absoluto:** $$ E=\frac{b-a}{2} $$
            </div>
        `,
        code: `
import numpy as np
import matplotlib.pyplot as plt

func_str = input("Ingrese la funci√≥n f(x): ")

def f(x):
    return eval(func_str, {"np": np, "x": x})

a = float(input("Ingrese el valor inicial a: "))
b = float(input("Ingrese el valor inicial b: "))

tol = 1e-6
max_iter = 100

print("\nIter | a          | b          | xm         | f(xm)      | Error")
print("---------------------------------------------------------------")

for i in range(1, max_iter+1):
    xm = (a + b)/2
    fxm = f(xm)
    error = (b - a)/2
    print(f"{i:4d} | {a:10.6f} | {b:10.6f} | {xm:10.6f} | {fxm:10.6f} | {error:10.6f}")
    
    if abs(fxm) < tol or error < tol:
        raiz = xm
        print(f"\nRa√≠z aproximada: {raiz:.6f} encontrada en {i} iteraciones")
        break
    
    if f(a)*fxm < 0:
        b = xm
    else:
        a = xm
else:
    print("\nNo se alcanz√≥ la convergencia despu√©s del m√°ximo de iteraciones")

# C√≥digo de graficaci√≥n (mantenido)
margen = (b - a)*0.1
xmin = a - margen
xmax = b + margen
x = np.linspace(xmin, xmax, 400)
y = f(x)

plt.plot(x, y, label=f"f(x) = {func_str}")
plt.axhline(0, color='black', linestyle='--')
plt.axvline(raiz, color='red', linestyle='--', label=f"Ra√≠z ‚âà {raiz:.6f}")
plt.title("M√©todo de Bisecci√≥n")
plt.xlabel("x")
plt.ylabel("f(x)")
plt.legend()
plt.grid(True)
plt.show()`
    },
    {
        id: 'a2',
        title: 'Actividad 2 ‚Äî M√©todo de la Secante',
        pdf: 'Secante.pdf',
        description: `
            <p>El m√©todo de la secante es un algoritmo de b√∫squeda de ra√≠ces de una funci√≥n que utiliza dos aproximaciones iniciales, $x_{n-1}$ y $x_n$. A diferencia del m√©todo de Newton-Raphson, **no requiere calcular la derivada** de la funci√≥n $f(x)$, aproxim√°ndola mediante la pendiente de la recta secante que pasa por los puntos $(x_{n-1}, f(x_{n-1}))$ y $(x_n, f(x_n))$</p>

            <div class="formula">
                $$ x_{n+1} = x_n - f(x_n)\,\\frac{x_n - x_{n-1}}{f(x_n) - f(x_{n-1})} $$
            </div>

            <p>**Nota:** Este m√©todo puede converger m√°s r√°pido que la bisecci√≥n (con orden $\phi \approx 1.618$), pero no siempre est√° garantizada la convergencia si los puntos iniciales no son cercanos a la ra√≠z.</p>
        `,
        code: `
import numpy as np
import matplotlib.pyplot as plt

# === 1. Ingreso de la funci√≥n ===
func_str = input("Ingrese la funci√≥n f(x): ")

# Definir la funci√≥n
def f(x):
    return eval(func_str, {"np": np, "x": x})

# === 2. Graficar la funci√≥n ===
xmin = float(input("Ingrese el valor m√≠nimo de x: "))
xmax = float(input("Ingrese el valor m√°ximo de x: "))

x = np.linspace(xmin, xmax, 400)
y = f(x)

plt.figure(figsize=(8, 5))
plt.plot(x, y, label=f"f(x) = {func_str}", color='blue')
plt.axhline(0, color='black', linestyle='--')
plt.axvline(0, color='black', linestyle='--')
plt.title("Gr√°fico de la funci√≥n ingresada")
plt.xlabel("x")
plt.ylabel("f(x)")
plt.legend()
plt.grid(True)
plt.show()

# === 3. Pregunta si desea aplicar el m√©todo de la Secante ===
op = input("¬øDesea encontrar una ra√≠z con el m√©todo de la Secante? (s/n): ").lower()

if op == "s":
    # === 4. Ingreso de puntos iniciales ===
    x0 = float(input("Ingrese el primer valor inicial x0: "))
    x1 = float(input("Ingrese el segundo valor inicial x1: "))

    tol = 1e-6
    max_iter = 100

    print("\nIteraci√≥n |      x0     |      x1     |    f(x0)    |    f(x1)    |      x2     |    Error")
    print("-----------------------------------------------------------------------------------------")

    for i in range(1, max_iter + 1):
        f0 = f(x0)
        f1 = f(x1)

        if f1 - f0 == 0:
            print(f"\n‚ö†Ô∏è Divisi√≥n por cero en la iteraci√≥n {i}. El m√©todo no puede continuar.")
            break

        # F√≥rmula de la Secante
        x2 = x1 - f1 * (x1 - x0) / (f1 - f0)
        error = abs(x2 - x1)

        print(f"{i:9d} | {x0:11.6f} | {x1:11.6f} | {f0:11.6f} | {f1:11.6f} | {x2:11.6f} | {error:10.6f}")

        if error < tol:
            print(f"\n‚úÖ Ra√≠z aproximada encontrada: {x2:.6f}")
            print(f"Iteraciones realizadas: {i}")
            break

        x0, x1 = x1, x2

    else:
        print("\n‚ö†Ô∏è No se alcanz√≥ la convergencia despu√©s de", max_iter, "iteraciones.")
else:
    print("No se aplic√≥ el m√©todo de la Secante.")
`
    },
    {
        id: 'a3',
        title: 'Actividad 3 ‚Äî M√©todo del Punto Fijo',
        pdf: 'Puntofijo.pdf',
        description: `
            <p>El m√©todo del punto fijo busca una soluci√≥n para la ecuaci√≥n $f(x)=0$ transform√°ndola en una forma equivalente $x=g(x)$. La ra√≠z $\alpha$ es entonces el punto fijo de $g(x)$, es decir, $\alpha = g(\alpha)$.</p>

            <div class="formula">
                $$ x_{n+1} = g(x_n) $$
            </div>

            <p>La **convergencia** est√° garantizada si la funci√≥n $g(x)$ es derivable en el intervalo que contiene la ra√≠z y su valor absoluto de la derivada es menor que uno en dicho intervalo: $|g'(x)| < 1$.</p>

            <div class="formula">
                **Condici√≥n de convergencia:** $$ |g'(x)| \le k < 1 $$
            </div>
        `,
        code: `
import numpy as np
import matplotlib.pyplot as plt

print("=== M√âTODO DEL PUNTO FIJO ===")

func_str = input("f(x) = ")
g_str = input("g(x) = ")

def f(x):
    return eval(func_str, {"np": np, "x": x})

def g(x):
    return eval(g_str, {"np": np, "x": x})

xmin = float(input("x m√≠n: "))
xmax = float(input("x m√°x: "))

x = np.linspace(xmin, xmax, 400)
y = f(x)

plt.plot(x, y, label=f"f(x)={func_str}", color='blue')
plt.axhline(0, color='black', linestyle='--')
plt.axvline(0, color='black', linestyle='--')
plt.legend()
plt.grid(True)
plt.show(block=False)

x0 = float(input("x0 = "))
tol = 1e-6
max_iter = 100

print("\nIter |       x_n      |      g(x_n)    |   f(g(x_n))    |     Error")
print("--------------------------------------------------------------------")

for i in range(1, max_iter + 1):
    x1 = g(x0)
    err = abs(x1 - x0)
    fx1 = f(x1)
    print(f"{i:4d} | {x0:14.8f} | {x1:14.8f} | {fx1:14.8f} | {err:10.8f}")
    if err < tol:
        print(f"\nRa√≠z ‚âà {x1:.8f}")
        break
    x0 = x1
else:
    print("\nNo se alcanz√≥ la convergencia despu√©s del m√°ximo de iteraciones")
`
    },
    {
        id: 'a4',
        title: 'Actividad 4 ‚Äî M√©todo de Regula Falsi',
        pdf: 'Regulafalsi.pdf',
        description: `
            <p>El m√©todo de **Regula Falsi** (o m√©todo de la falsa posici√≥n) es una mejora del m√©todo de bisecci√≥n. Se basa en trazar una recta secante entre los puntos finales $(a, f(a))$ y $(b, f(b))$ del intervalo, y usar la intersecci√≥n de esta secante con el eje $x$ como la nueva aproximaci√≥n a la ra√≠z ($x_r$).</p>

            <p>Al igual que bisecci√≥n, requiere que $f(a) \cdot f(b) < 0$ para acotar la ra√≠z.</p>

            <div class="formula">
                $$ x_r = b - f(b)\frac{b-a}{f(b)-f(a)} $$
            </div>

            <p>**Nota:** Este m√©todo mantiene la propiedad de convergencia de bisecci√≥n, pero generalmente converge m√°s r√°pido porque usa informaci√≥n de la funci√≥n, aunque la convergencia puede ser lenta si la funci√≥n es muy c√≥ncava o convexa cerca de la ra√≠z.</p>
        `,
        code: `
import numpy as np
import matplotlib.pyplot as plt

func_str = input("Ingrese la funci√≥n f(x): ")

def f(x):
    return eval(func_str, {"np": np, "x": x})

a = float(input("Ingrese el valor inicial a: "))
b = float(input("Ingrese el valor inicial b: "))

if f(a) * f(b) >= 0:
    print("Error: f(a) y f(b) deben tener signos opuestos.")
else:
    tol = 1e-6
    max_iter = 100
    raiz = None

    print("\nIter | a          | b          | xr         | f(xr)      | Error")
    print("---------------------------------------------------------------")

    for i in range(1, max_iter+1):
        fa = f(a)
        fb = f(b)
        
        # F√≥rmula de Regula Falsi
        xr = b - fb * (b - a) / (fb - fa)
        fxr = f(xr)
        error = abs(fxr)
        
        print(f"{i:4d} | {a:10.6f} | {b:10.6f} | {xr:10.6f} | {fxr:10.6f} | {error:10.6f}")
        
        if abs(fxr) < tol:
            raiz = xr
            print(f"\nRa√≠z aproximada: {raiz:.6f} encontrada en {i} iteraciones")
            break
        
        if fa * fxr < 0:
            b = xr
        else:
            a = xr
    else:
        print("\nNo se alcanz√≥ la convergencia despu√©s del m√°ximo de iteraciones")

    # C√≥digo de graficaci√≥n
    if raiz is not None:
        margen = (max(b, raiz) - min(a, raiz)) * 0.1
        xmin = min(a,b,raiz) - margen
        xmax = max(a,b,raiz) + margen
        x = np.linspace(xmin, xmax, 400)
        y = f(x)

        plt.plot(x, y, label=f"f(x) = {func_str}")
        plt.axhline(0, color='black', linestyle='--')
        plt.axvline(raiz, color='red', linestyle='--', label=f"Ra√≠z ‚âà {raiz:.6f}")
        plt.title("M√©todo de Regula Falsi")
        plt.xlabel("x")
        plt.ylabel("f(x)")
        plt.legend()
        plt.grid(True)
        plt.show()`
    },
    {
        id: 'a5',
        title: 'Actividad 5 ‚Äî M√©todo de Newton-Raphson',
        pdf: 'Actividad_05.pdf',
        description: `
            <p>El m√©todo de **Newton-Raphson** es un m√©todo iterativo muy eficiente para encontrar ra√≠ces de funciones reales. Se basa en el desarrollo de la funci√≥n en serie de Taylor alrededor del punto actual y truncando despu√©s del primer t√©rmino, lo que equivale a usar la recta tangente a la funci√≥n en $x_n$ para estimar el siguiente punto, $x_{n+1}$.</p>
            
            <div class="formula">
                $$ x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)} $$
            </div>

            <p>**Requisitos:** Requiere que la funci√≥n sea derivable y que su derivada $f'(x)$ sea calculable y no nula cerca de la ra√≠z. Tiende a la convergencia cuadr√°tica (muy r√°pida) si la suposici√≥n inicial es suficientemente cercana a la ra√≠z. En este c√≥digo, la derivada se calcula num√©ricamente por diferencias finitas.</p>
        `,
        code: `
import numpy as np
import matplotlib.pyplot as plt
import time

ecuacion = input("Ingrese la funci√≥n f(x): ")

def f(x):
    # Usamos eval de forma controlada para ejecutar la funci√≥n
    return eval(ecuacion, {"np": np, "__builtins__": None, "x": x})

def derivada(x):
    # Aproximaci√≥n num√©rica de la derivada por diferencia central
    h = 1e-6
    return (f(x + h) - f(x - h)) / (2 * h)

a = float(input("Ingrese el l√≠mite inferior del eje x: "))
b = float(input("Ingrese el l√≠mite superior del eje x: "))

x_vals = np.linspace(a, b, 400)
y_vals = f(x_vals)

plt.figure(figsize=(8, 5))
plt.plot(x_vals, y_vals, 'b', label=f"f(x) = {ecuacion}")
plt.axhline(0, color='black', linestyle='--')
plt.axvline(0, color='black', linestyle='--')
plt.title("Gr√°fico de la funci√≥n ingresada")
plt.xlabel("x")
plt.ylabel("f(x)")
plt.legend()
plt.grid(True)
plt.show(block=False)
time.sleep(3)
plt.close()

x = float(input("Ingrese el valor inicial aproximado: "))
tolerancia = 1e-6
iter_max = 100

print("\nIter | x_n         | f(x_n)      | f'(x_n)     | Error")
print("--------------------------------------------------------------------")

for i in range(iter_max):
    fx = f(x)
    dfx = derivada(x)
    
    if abs(dfx) < 1e-10: # Cuidado con la divisi√≥n por cero
        print(f"La derivada es cero en x = {x:.6f}. No se puede continuar.")
        break
        
    x_nuevo = x - fx / dfx
    error = abs(x_nuevo - x)
    
    print(f"{i+1:4d} | {x:11.6f} | {fx:11.6f} | {dfx:11.6f} | {error:8.6f}")

    if error < tolerancia:
        print(f"\nRa√≠z encontrada: {x_nuevo:.6f}")
        print(f"N√∫mero de iteraciones: {i + 1}")
        break
        
    x = x_nuevo
else:
    print(f"\nNo se logr√≥ la convergencia despu√©s de {iter_max} iteraciones.")
    print(f"√öltimo valor aproximado: {x:.6f}")
`
    },
    // --- INICIO ACTIVIDADES MODIFICADAS/REESCRITAS (6 a 12) ---
    {
        id: 'a6',
        title: 'Actividad 6 ‚Äî √çndice H (M√©trica Bibliom√©trica)',
        pdf: 'Actividad6.pdf',
        description: `
            <p>El **√çndice H** (o √≠ndice de Hirsch) es una m√©trica bibliom√©trica propuesta en 2005 para cuantificar la productividad y el impacto de un investigador. Combina la cantidad de publicaciones con la frecuencia de sus citaciones.</p>
            <p>Se define de la siguiente manera: Un cient√≠fico tiene un √≠ndice $h$ si $h$ de sus publicaciones tienen al menos $h$ citaciones cada una, y el resto tienen $\le h$ citaciones.</p>

            <div class="formula">
                **Definici√≥n Formal:**
                $$ h = \max \{i \in \mathbb{N} : \text{La publicaci√≥n } i \text{ tiene al menos } i \text{ citas} \} $$
            </div>

            <h4>Autores Clave en M√©todos Num√©ricos (Ejemplos de √çndice H)</h4>
            <p>La siguiente tabla muestra el √çndice H de los autores principales en el material de referencia (los enlaces son ejemplos de Scopus ID):</p>
            <table class="activity-table">
                <thead>
                    <tr>
                        <th>Autor</th>
                        <th>Investigaci√≥n Central</th>
                        <th>Enlace de Referencia</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Grau, √Ängela</td>
                        <td>M√©todos Secantes para sistemas no lineales</td>
                        <td><a href="https://www.scopus.com/authid/detail.uri?authorId=36545025500" target="_blank">Ver Scopus ID</a></td>
                    </tr>
                    <tr>
                        <td>D√≠az-Barrero, Jos√© Luis</td>
                        <td>Convergencia de m√©todos iterativos</td>
                        <td><a href="https://www.scopus.com/authid/detail.uri?authorId=6602720000" target="_blank">Ver Scopus ID</a></td>
                    </tr>
                    <tr>
                        <td>Argyros, Ioannis K.</td>
                        <td>Algoritmos para problemas no lineales</td>
                        <td><a href="https://www.scopus.com/authid/detail.uri?authorId=7004530784" target="_blank">Ver Scopus ID</a></td>
                    </tr>
                </tbody>
            </table>

            <h4>√çndice H de Docentes de la Facultad (Ejemplo de aplicaci√≥n)</h4>
            <p>El √çndice H permite evaluar el impacto de la investigaci√≥n local:</p>
            <table class="activity-table">
                <thead>
                    <tr>
                        <th>Docente (Enlace a Scopus ID)</th>
                        <th>√çndice H</th>
                        <th>N¬∞ publicaciones</th>
                    </tr>
                </thead>
                <tbody>
                    <tr><td><a href="https://www.scopus.com/authid/detail.uri?authorId=57224362115" target="_blank">Apaza-Tarqui, Alejandro</a></td><td>1</td><td>5</td></tr>
                    <tr><td><a href="https://www.scopus.com/authid/detail.uri?authorId=57221112735" target="_blank">Carpio Vargas, Edgar Eloy</a></td><td>3</td><td>9</td></tr>
                    <tr><td><a href="https://www.scopus.com/authid/detail.uri?authorId=57214094525" target="_blank">Canqui-Flores, Bernab√©</a></td><td>3</td><td>8</td></tr>
                    <tr><td><a href="https://www.scopus.com/authid/detail.uri?authorId=58491331500" target="_blank">Choquejahua-Acero, Remo</a></td><td>1</td><td>2</td></tr>
                    <tr><td><a href="https://www.scopus.com/authid/detail.uri?authorId=58930847700" target="_blank">Coyla-Idme, Leonel</a></td><td>1</td><td>5</td></tr>
                    <tr><td><a href="https://www.scopus.com/authid/detail.uri?authorId=58898481200" target="_blank">Gonzales, Leonid Alem√°n</a></td><td>0</td><td>4</td></tr>
                    <tr><td><a href="https://www.scopus.com/authid/detail.uri?authorId=59325707300" target="_blank">Gonzalo Copari Romero, Fredy</a></td><td>0</td><td>2</td></tr>
                    <tr><td><a href="https://www.scopus.com/authid/detail.uri?authorId=57571711100" target="_blank">Huata-Panca, Percy</a></td><td>2</td><td>3</td></tr>
                    <tr><td><a href="https://www.scopus.com/authid/detail.uri?authorId=57201897173" target="_blank">Iba√±ez-Quispe, Vladimiro</a></td><td>5</td><td>21</td></tr>
                    <tr><td><a href="https://www.scopus.com/authid/detail.uri?authorId=55865380000" target="_blank">Javier Quispe Carita, Angel</a></td><td>1</td><td>1</td></tr>
                    <tr><td><a href="https://www.scopus.com/authid/detail.uri?authorId=58284593600" target="_blank">Laura Murillo, Ramiro</a></td><td>1</td><td>2</td></tr>
                    <tr><td><a href="https://www.scopus.com/authid/detail.uri?authorId=58671914800" target="_blank">L√≥pez-Cueva, Milton Antonio</a></td><td>1</td><td>6</td></tr>
                    <tr><td><a href="https://www.scopus.com/authid/detail.uri?authorId=58778725100" target="_blank">Melgarejo-Bolivar, Romel P.</a></td><td>3</td><td>6</td></tr>
                    <tr><td><a href="https://www.scopus.com/authid/detail.uri?authorId=57562709900" target="_blank">Mendoza-Mollocondo, Charles Ignacio</a></td><td>3</td><td>8</td></tr>
                    <tr><td><a href="https://www.scopus.com/authid/detail.uri?authorId=58308326900" target="_blank">Herrera-Urtiaga, Alain Paul</a></td><td>0</td><td>3</td></tr>
                    <tr><td><a href="https://www.scopus.com/authid/detail.uri?authorId=58088282100" target="_blank">Tito Lipa, Jos√© P√°nfilo</a></td><td>0</td><td>3</td></tr>
                    <tr><td><a href="https://www.scopus.com/authid/detail.uri?authorId=57003617100" target="_blank">Tumi-Figueroa, Ernesto Nayer</a></td><td>3</td><td>6</td></tr>
                </tbody>
            </table>
        `,
        code: `
/**
 * Python/Pseudoc√≥digo para calcular el √çndice H
 * El c√≥digo real requiere acceso a bases de datos bibliom√©tricas (Scopus, WoS, etc.)
 * Este es un ejemplo conceptual basado en un array de citas.
 */
def calcular_indice_h(citas):
    """
    Calcula el √çndice H a partir de un array de n√∫meros de citas.
    @param citas: Lista de enteros representando el n√∫mero de citas de cada art√≠culo.
    @return: El valor del √çndice H.
    """
    if not citas:
        return 0

    # 1. Ordenar las citas de forma descendente
    citas.sort(reverse=True)

    h_index = 0
    # 2. Recorrer la lista para encontrar el √≠ndice 'h'
    for i in range(len(citas)):
        # El art√≠culo en la posici√≥n i (que tiene i+1 art√≠culos con al menos esa cantidad)
        # debe tener un n√∫mero de citas >= (i + 1)
        if citas[i] >= (i + 1):
            h_index = i + 1
        else:
            # Una vez que la condici√≥n no se cumple, el valor anterior es el m√°ximo h
            break
            
    return h_index

# Ejemplo de uso:
# Un autor tiene 6 art√≠culos con 10, 8, 5, 4, 2, 1 citas.
ejemplo_citas = [10, 8, 5, 4, 2, 1] 
# h=4: 4 art√≠culos tienen 4 o m√°s citas (10, 8, 5, 4).
# Art√≠culo 5 (con 2 citas) NO tiene 5 o m√°s citas.
# print(calcular_indice_h(ejemplo_citas)) # Salida: 4

`
    },
    {
        id: 'a7',
        title: 'Actividad 7 ‚Äî Gradiente de una Funci√≥n (Descenso por Gradiente)',
        pdf: 'actividad_8.pdf',
        description: `
            <p>El **Gradiente** ($\nabla f$) de una funci√≥n escalar multivariable es un vector que apunta en la direcci√≥n de m√°ximo crecimiento de la funci√≥n. En el contexto de optimizaci√≥n, el m√©todo de **Descenso por Gradiente** se utiliza para encontrar el m√≠nimo local de una funci√≥n de coste (Loss Function) movi√©ndose en la direcci√≥n opuesta al gradiente.</p>

            <div class="formula">
                **Vector Gradiente (Funci√≥n Multivariable):**
                $$ \nabla f(\mathbf{x}) = \begin{pmatrix} \frac{\partial f}{\partial x_1} \\ \frac{\partial f}{\partial x_2} \\ \vdots \\ \frac{\partial f}{\partial x_n} \end{pmatrix} $$
            </div>

            <div class="formula">
                **Regla de Actualizaci√≥n (Descenso por Gradiente):**
                $$ \mathbf{x}_{k+1} = \mathbf{x}_k - \eta \nabla f(\mathbf{x}_k) $$
            </div>

            <p>Donde $\mathbf{x}_k$ es el vector de variables en la iteraci√≥n $k$, $\nabla f(\mathbf{x}_k)$ es el gradiente de la funci√≥n de coste evaluado en $\mathbf{x}_k$, y $\eta$ (eta) es la **tasa de aprendizaje** (Learning Rate), que controla el tama√±o del paso.</p>
        `,
        code: `
# C√≥digo de ejemplo en R para un Descenso por Gradiente simple
# Funci√≥n de Coste: f(x) = x^2 (M√≠nimo en x=0)
# Gradiente (Derivada): f'(x) = 2x

n <- 0.01  # Tasa de aprendizaje (Learning Rate)
f <- function(x) x^2
f_deriv <- function(x) 2 * x

x0 <- 3    # Punto inicial
iter_max <- 21

x_hist <- numeric(iter_max)
x_hist[1] <- x0
print(paste("Iteraci√≥n 0: x =", x0))

for (i in 1:(iter_max - 1)) {
    # Calcular el gradiente
    grad_x <- f_deriv(x_hist[i])
    
    # Aplicar la regla de actualizaci√≥n: x_nuevo = x_actual - eta * gradiente
    x_hist[i + 1] <- x_hist[i] - n * grad_x
    
    print(paste("Iteraci√≥n", i, ": x =", round(x_hist[i + 1], 6), 
                ", f(x) =", round(f(x_hist[i + 1]), 6)))
}

# El resultado final (x_hist[iter_max]) se aproxima a 0.
`
    },
    {
        id: 'a8',
        title: 'Actividad 8 ‚Äî Pseudoinverso vs. Descenso de Gradiente en Regresi√≥n Lineal',
        pdf: 'iamgen 1.pdf',
        description: `
            <p>Este art√≠culo contrasta dos m√©todos fundamentales para resolver el problema de la **Regresi√≥n Lineal por M√≠nimos Cuadrados Ordinarios (OLS)**: el uso de la soluci√≥n de forma cerrada a trav√©s del **Pseudoinverso de Moore-Penrose** y el m√©todo iterativo del **Descenso de Gradiente**.</p>
            
            <h4>1. Pseudoinverso de Moore-Penrose (Soluci√≥n Anal√≠tica)</h4>
            <p>Proporciona la soluci√≥n exacta para los coeficientes $\mathbf{w}$ que minimizan el error cuadr√°tico. Se basa en la ecuaci√≥n normal:</p>
            
            <div class="formula">
                **Soluci√≥n Anal√≠tica (Pesos $\mathbf{w}$):**
                $$ \mathbf{w} = (\mathbf{X}^T\mathbf{X})^{-1}\mathbf{X}^T\mathbf{y} $$
                **Donde $\mathbf{X}^T\mathbf{X})^{-1}\mathbf{X}^T$ es el Pseudoinverso $\mathbf{X}^{\dagger}$.**
            </div>

            <p>**Ventajas:** Exactitud y bajo error. **Desventajas:** Alto costo computacional e inestabilidad num√©rica para matrices de caracter√≠sticas ($\mathbf{X}$) grandes o mal condicionadas (soluci√≥n por SVD).</p>

            <h4>2. Descenso de Gradiente (Soluci√≥n Iterativa)</h4>
            <p>Minimiza la **funci√≥n de coste (Error Cuadr√°tico Medio - MSE)** iterativamente, ajustando los pesos en la direcci√≥n opuesta al gradiente de la funci√≥n de coste. La funci√≥n de coste $J(\mathbf{w})$ es:</p>

            <div class="formula">
                **Funci√≥n de Coste (MSE):**
                $$ J(\mathbf{w}) = \frac{1}{2m} \sum_{i=1}^{m} (h_\mathbf{w}(\mathbf{x}^{(i)}) - y^{(i)})^2 $$
            </div>

            <p>**Ventajas:** Escalabilidad y eficiencia para grandes conjuntos de datos. **Desventajas:** Sensibilidad a la tasa de aprendizaje ($\eta$) y a la necesidad de normalizaci√≥n/escalado de las variables para asegurar una convergencia eficiente.</p>
        `,
        code: `
# C√≥digo conceptual (no funcional) para ilustrar ambos m√©todos

def pseudoinverso_ols(X, y):
    """Soluci√≥n anal√≠tica usando el pseudoinverso (linalg.pinv)."""
    # X_dagger = np.linalg.pinv(X)
    # w = X_dagger @ y
    return "Retorna la soluci√≥n de forma cerrada (√≥ptima)"

def descenso_gradiente(X, y, learning_rate, max_iter):
    """Soluci√≥n iterativa usando el descenso de gradiente."""
    # w = np.zeros(X.shape[1])
    # for i in range(max_iter):
    #     pred = X @ w
    #     error = pred - y
    #     gradiente = X.T @ error / len(y)
    #     w = w - learning_rate * gradiente
    # return w
    return "Retorna una aproximaci√≥n a la soluci√≥n despu√©s de N iteraciones"

print("Comparaci√≥n de rendimiento:")
print("‚Ä¢ Pseudoinverso: Mejor para datasets peque√±os/moderados y bien condicionados.")
print("‚Ä¢ Descenso de Gradiente: Mejor para datasets masivos y alta dimensionalidad.")
`
    },
    {
        id: 'a9',
        title: 'Actividad 9 ‚Äî Din√°mica del Juego de Caramelos y Chupetines (Simulaci√≥n Estoc√°stica)',
        pdf: 'Dinamica (2).pdf',
        description: `
            <p>Esta actividad describe la simulaci√≥n de un **juego cooperativo estoc√°stico** modelado en R, donde el objetivo es alcanzar un estado final espec√≠fico (un chupet√≠n 'D' por jugador) a partir de un conjunto inicial de recursos aleatorios (caramelos 'A', 'B', 'C').</p>
            
            <p>La simulaci√≥n utiliza **reglas de transici√≥n de estado** basadas en el inventario actual de caramelos y un componente estoc√°stico (aleatorio) para la reposici√≥n de recursos. Los estados y las transiciones se rigen por las siguientes reglas:</p>

            <div class="formula">
                **Regla de Creaci√≥n 1 (1D):**
                $$ \{A \ge 1, B \ge 1, C \ge 1\} \Rightarrow \text{Crear } 1D, \text{ consumir } \{1A, 1B, 1C\} $$
            </div>

            <div class="formula">
                **Regla de Creaci√≥n 2 (2D + Reposici√≥n):**
                $$ \{A \ge 2, B \ge 2, C \ge 2\} \Rightarrow \text{Crear } 2D, \text{ consumir } \{2A, 2B, 2C\}, \text{ y a√±adir 1 caramelo aleatorio} $$
            </div>
            
            <p>La din√°mica cesa cuando se cumple la **condici√≥n de victoria** (chupetines $\ge$ n√∫mero de jugadores) o se alcanza el l√≠mite de iteraciones, sirviendo como ejemplo de modelado de sistemas complejos y din√°micos.</p>
        `,
        code: `
# C√≥digo conceptual en R (Simulaci√≥n Estoc√°stica)

# Inicializaci√≥n
JUGADORES <- 5
BOLSA <- list(A=0, B=0, C=0, D=0)
MAX_ITER <- 100
set.seed(42) # Para reproducibilidad

# Funci√≥n para a√±adir caramelo aleatorio (Simulaci√≥n estoc√°stica)
a√±adir_aleatorio <- function(bolsa) {
  tipo <- sample(c('A', 'B', 'C'), 1)
  bolsa[[tipo]] <- bolsa[[tipo]] + 1
  return(bolsa)
}

# Bucle principal de la simulaci√≥n
for (i in 1:MAX_ITER) {
  
  # 1. Aplicar Regla de Creaci√≥n 2 (Prioridad)
  if (BOLSA$A >= 2 && BOLSA$B >= 2 && BOLSA$C >= 2) {
    BOLSA$A <- BOLSA$A - 2
    BOLSA$B <- BOLSA$B - 2
    BOLSA$C <- BOLSA$C - 2
    BOLSA$D <- BOLSA$D + 2
    BOLSA <- a√±adir_aleatorio(BOLSA)
    print(paste("Iter", i, ": Regla 2 aplicada (2D + reposici√≥n). Bolsa:", paste(unlist(BOLSA), collapse=", ")))
    
  } 
  # 2. Aplicar Regla de Creaci√≥n 1
  else if (BOLSA$A >= 1 && BOLSA$B >= 1 && BOLSA$C >= 1) {
    BOLSA$A <- BOLSA$A - 1
    BOLSA$B <- BOLSA$B - 1
    BOLSA$C <- BOLSA$C - 1
    BOLSA$D <- BOLSA$D + 1
    print(paste("Iter", i, ": Regla 1 aplicada (1D). Bolsa:", paste(unlist(BOLSA), collapse=", ")))
    
  }
  
  # 3. Condici√≥n de Victoria
  if (BOLSA$D >= JUGADORES) {
    print(paste("¬°VICTORIA! Objetivo alcanzado en", i, "iteraciones."))
    break
  }
  
  # 4. Regla de Intercambio (Si no hay m√°s creaciones posibles)
  if (i %% 5 == 0 && BOLSA$D >= 1) { # Intenta intercambio cada 5 turnos
      BOLSA$D <- BOLSA$D - 1
      BOLSA <- a√±adir_aleatorio(BOLSA)
      BOLSA <- a√±adir_aleatorio(BOLSA)
      BOLSA <- a√±adir_aleatorio(BOLSA)
      print(paste("Iter", i, ": Intercambio D por 3 caramelos aleatorios."))
  }
  
  if (i == MAX_ITER) {
      print("FIN: L√≠mite de iteraciones alcanzado. No se alcanz√≥ la victoria.")
  }
}
`
    },
    {
        id: 'a10',
        title: 'Actividad 10 ‚Äî Registraci√≥n No R√≠gida de Im√°genes (M√©todo Demons)',
        pdf: 'tarea de resumenes.pdf',
        description: `
            <p>El art√≠culo se centra en la **registraci√≥n no r√≠gida** de im√°genes m√©dicas, un proceso cr√≠tico para alinear datos obtenidos de distintos escaneos o sensores. La registraci√≥n no r√≠gida permite modelar las deformaciones locales de los tejidos biol√≥gicos, a diferencia de la registraci√≥n r√≠gida que solo permite traslaciones y rotaciones.</p>

            <p>El m√©todo principal discutido es el algoritmo **Demons**, que modela el campo de deformaci√≥n entre la imagen flotante ($I_F$) y la imagen de referencia ($I_R$) bas√°ndose en el **flujo √≥ptico**. La deformaci√≥n es vista como un movimiento de "demons" que empujan a la imagen flotante hacia la imagen de referencia.</p>

            <div class="formula">
                **Desplazamiento del V√≥xel $v$ (Versi√≥n Simple de Demons):**
                $$ \mathbf{v}(\mathbf{x}) = \frac{(I_R(\mathbf{x}) - I_F(\mathbf{x})) \cdot \nabla I_R(\mathbf{x})}{\| \nabla I_R(\mathbf{x}) \|^2 + (I_R(\mathbf{x}) - I_F(\mathbf{x}))^2} \cdot \nabla I_R(\mathbf{x}) $$
            </div>

            <p>Donde $I_R(\mathbf{x})$ y $I_F(\mathbf{x})$ son la intensidad del v√≥xel $\mathbf{x}$ en las im√°genes de referencia y flotante, y $\nabla I_R(\mathbf{x})$ es el vector gradiente de la imagen de referencia. El art√≠culo se√±ala que las variantes m√°s avanzadas incorporan informaci√≥n direccional y de regularizaci√≥n para manejar grandes deformaciones y mejorar la precisi√≥n.</p>
        `,
        code: `
# Pseudoc√≥digo/Comentario: La implementaci√≥n del m√©todo Demons 
# es compleja y t√≠picamente se realiza usando librer√≠as avanzadas 
# (ej. ITK, SimpleITK en Python/C++).

# === Pasos generales del Algoritmo Demons ===
# 1. Inicializar el Campo de Deformaci√≥n (DVF) a cero.
# 2. Iterar hasta la convergencia:
#    a. Deformar la Imagen Flotante: I_deformada = I_F(DVF).
#    b. Calcular el Desplazamiento (v): Usando la f√≥rmula del gradiente/intensidad.
#    c. Suavizar/Regularizar v: Aplicar un filtro gaussiano (opcional, para estabilidad).
#    d. Componer/Actualizar el DVF: DVF_nuevo = DVF + v.
# 3. Resultado: El DVF final.

`
    },
    {
        id: 'a11',
        title: 'Actividad 11 ‚Äî Diferenciaci√≥n Num√©rica (F√≥rmulas de Diferencias Finitas)',
        pdf: 'Actividad11 (1).pdf',
        description: `
            <p>La **Diferenciaci√≥n Num√©rica** consiste en aproximar la derivada de una funci√≥n $f(x)$ utilizando sus valores en un conjunto discreto de puntos. El concepto se basa en la definici√≥n de la derivada, pero con un paso $h$ peque√±o pero finito.</p>

            <div class="formula">
                **Definici√≥n de la Derivada:**
                $$ f'(x) = \lim_{h \to 0} \frac{f(x + h) - f(x)}{h} $$
            </div>

            <p>Las aproximaciones m√°s comunes se conocen como **F√≥rmulas de Diferencias Finitas**:</p>

            <h4>1. Diferencia Adelante (Forward Difference)</h4>
            <p>Aproxima la pendiente usando el punto actual y el siguiente.</p>
            <div class="formula">
                $$ f'(x) \approx \frac{f(x + h) - f(x)}{h} + O(h) $$
            </div>

            <h4>2. Diferencia Atr√°s (Backward Difference)</h4>
            <p>Aproxima la pendiente usando el punto actual y el anterior.</p>
            <div class="formula">
                $$ f'(x) \approx \frac{f(x) - f(x - h)}{h} + O(h) $$
            </div>

            <h4>3. Diferencia Central (Central Difference)</h4>
            <p>Aproxima la pendiente usando los puntos vecino anterior y posterior. Es generalmente la m√°s precisa ($O(h^2)$).</p>
            <div class="formula">
                $$ f'(x) \approx \frac{f(x + h) - f(x - h)}{2h} + O(h^2) $$
            </div>
            <p>La notaci√≥n $O(h)$ u $O(h^2)$ representa el orden del error de truncamiento.</p>
        `,
        code: `
import numpy as np

# Ejemplo de aproximaci√≥n de la derivada de f(x) = x^3 en x=2
def f(x):
    return x**3

x = 2.0
h = 0.01

# 1. Diferencia Adelante
f_prime_adelante = (f(x + h) - f(x)) / h

# 2. Diferencia Atr√°s
f_prime_atras = (f(x) - f(x - h)) / h

# 3. Diferencia Central (m√°s precisa)
f_prime_central = (f(x + h) - f(x - h)) / (2 * h)

# Derivada anal√≠tica real: f'(x) = 3*x^2. En x=2, f'(2) = 12
real = 3 * x**2

print(f"Funci√≥n: f(x) = x^3. Derivada real en x={x}: {real}")
print(f"H = {h}")
print(f"Diferencia Adelante: {f_prime_adelante:.6f} (Error: {abs(f_prime_adelante - real):.6f})")
print(f"Diferencia Atr√°s:  {f_prime_atras:.6f} (Error: {abs(f_prime_atras - real):.6f})")
print(f"Diferencia Central:  {f_prime_central:.6f} (Error: {abs(f_prime_central - real):.6f})")

`
    },
    {
        id: 'a12',
        title: 'Actividad 12 ‚Äî Ecuaciones Diferenciales Ordinarias (M√©todo de Euler)',
        pdf: 'Actividad_12.pdf',
        description: `
            <p>El **M√©todo de Euler** es el m√©todo num√©rico m√°s simple para resolver Ecuaciones Diferenciales Ordinarias (EDO) de primer orden con un valor inicial. Se basa en la aproximaci√≥n de que la funci√≥n es localmente lineal, utilizando el primer t√©rmino de la expansi√≥n de Taylor para estimar el valor en el siguiente paso.</p>

            <p>Dada una EDO de la forma:</p>
            <div class="formula">
                $$ \frac{dy}{dx} = f(x, y), \quad \text{con condici√≥n inicial } y(x_0) = y_0 $$
            </div>

            <p>La f√≥rmula iterativa del M√©todo de Euler permite avanzar la soluci√≥n un paso de tama√±o $h$ a la vez:</p>
            <div class="formula">
                $$ y_{i+1} = y_i + f(x_i, y_i) \cdot h $$
            </div>

            <p>Donde $h = x_{i+1} - x_i$ es el tama√±o del paso, y $f(x_i, y_i)$ es la pendiente (derivada) en el punto actual. Este m√©todo tiene un error de truncamiento local de orden $O(h^2)$ y un error global de orden $O(h)$, por lo que requiere pasos $h$ peque√±os para ser preciso.</p>
        `,
        code: `
import numpy as np
import matplotlib.pyplot as plt

# Definir la EDO: dy/dx = f(x, y)
# Ejemplo: dy/dx = -2xy^2 (Soluci√≥n real: y = 1 / (1 + x^2))
def f(x, y):
    return -2 * x * y**2

# Par√°metros iniciales
x0 = 0.0 # Valor inicial de x
y0 = 1.0 # Valor inicial de y(x0)
xf = 2.0 # Valor final de x
h = 0.1  # Tama√±o del paso (step size)

# Configuraci√≥n del m√©todo
n_steps = int((xf - x0) / h)
x_vals = np.linspace(x0, xf, n_steps + 1)
y_euler = np.zeros(n_steps + 1)

# Condici√≥n inicial
y_euler[0] = y0

print("i | x_i | y_i (Aprox) | f(x_i, y_i)")
print("---------------------------------------")

# Bucle del M√©todo de Euler
for i in range(n_steps):
    x_i = x_vals[i]
    y_i = y_euler[i]
    
    # Calcular la pendiente (derivada)
    slope = f(x_i, y_i)
    
    # Aplicar la f√≥rmula de Euler: y_i+1 = y_i + f(x_i, y_i) * h
    y_euler[i + 1] = y_i + slope * h
    
    print(f"{i:1d} | {x_i:.1f} | {y_i:.6f} | {slope:.6f}")

# Graficaci√≥n
plt.figure(figsize=(8, 5))
plt.plot(x_vals, y_euler, 'b-o', label=f"Euler (h={h})")

# Soluci√≥n real (para comparaci√≥n)
y_real = 1 / (1 + x_vals**2)
plt.plot(x_vals, y_real, 'r--', label="Soluci√≥n Real")

plt.title("M√©todo de Euler para EDOs")
plt.xlabel("x")
plt.ylabel("y(x)")
plt.legend()
plt.grid(True)
plt.show()
`
    }
];

// L√≥gica de Interfaz y Eventos (Mantenida y adaptada)
const grid = document.getElementById('activitiesGrid');
const detailScreen = document.getElementById('detailScreen');
const detailTitle = document.getElementById('detailTitle');
const detailEnunciado = document.getElementById('detailEnunciado');
const detailCode = document.getElementById('detailCode');
const openPdfBtn = document.getElementById('openPdfBtn');
const downloadCodeBtn = document.getElementById('downloadCodeBtn');
const closeDetailBtn = document.getElementById('closeDetailBtn');
const floatingCloseBtn = document.getElementById('floatingClose');
const floatingBack = document.getElementById('floatingBack');
const downloadAnchor = document.getElementById('downloadAnchor');

function renderActivities() {
    grid.innerHTML = '';
    activities.forEach(activity => {
        const card = document.createElement('div');
        card.className = 'card';
        card.innerHTML = `<h3>${activity.title}</h3><p>${activity.description.substring(0, 80).replace(/<[^>]*>?/gm, '...')}...</p>`;
        card.onclick = () => showDetail(activity);
        grid.appendChild(card);
    });
}

function showDetail(activity) {
    detailTitle.textContent = activity.title;
    
    // Inyectar el HTML de description (incluyendo las f√≥rmulas y tablas)
    detailEnunciado.innerHTML = activity.description; 
    
    // Inyectar el texto plano del c√≥digo, manteniendo su formato para descarga
    detailCode.textContent = activity.code; 
    
    // Configurar bot√≥n PDF
    openPdfBtn.onclick = () => window.open(activity.pdf, '_blank');

    // Re-renderizar MathJax en el contenido din√°mico
    if (window.MathJax) {
        // Tip: El uso de typesetPromise asegura que se renderice despu√©s de inyectar el contenido
        MathJax.typesetPromise([detailEnunciado]); 
    }

    // Mostrar el modal
    detailScreen.classList.add('show');
    detailScreen.setAttribute('aria-hidden', 'false');
    floatingBack.style.display = 'block';
}

function closeDetail() {
    detailScreen.classList.remove('show');
    detailScreen.setAttribute('aria-hidden', 'true');
    floatingBack.style.display = 'none';
}

function downloadCode() {
    const codeContent = detailCode.textContent;
    const activityId = detailTitle.textContent.replace(/[^a-zA-Z0-9]/g, '_');
    const filename = `${activityId}.txt`;
    
    const blob = new Blob([codeContent], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    
    downloadAnchor.href = url;
    downloadAnchor.download = filename;
    downloadAnchor.click();
    
    // Limpiar el objeto URL
    URL.revokeObjectURL(url);
}

// Event Listeners para cerrar el modal
closeDetailBtn.onclick = closeDetail;
floatingCloseBtn.onclick = closeDetail;
downloadCodeBtn.onclick = downloadCode;

// Inicializar la aplicaci√≥n
document.addEventListener('DOMContentLoaded', renderActivities);

// Asegurar el cierre del modal con la tecla ESC
document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && detailScreen.classList.contains('show')) {
        closeDetail();
    }
});

</script>

</body>
</html>
